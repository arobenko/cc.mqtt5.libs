#include <algorithm>
#include <cassert>
#include <cstdint>
#include <cstddef>
#include <fstream>
#include <iostream>
#include <limits>
#include <memory>
#include <thread>
#include <vector>

#include <unistd.h>

#include "##NAME##client.h"

#include "cc_mqtt5/Message.h"
#include "cc_mqtt5/frame/Frame.h"


namespace 
{

const std::size_t BufSize = 1024000;
const unsigned IterCount = 10000;

struct AflFuzzDeleter
{
    void operator()(CC_Mqtt5Client* ptr)
    {
        cc_mqtt5_##NAME##client_free(ptr);
    }
}; 

using AflFuzzClientPtr = std::unique_ptr<CC_Mqtt5Client, AflFuzzDeleter>;

struct State
{
    std::ostream* m_log = nullptr;
    CC_Mqtt5ClientHandle m_client = nullptr;
    std::vector<std::uint8_t> m_inData;
    unsigned m_nextTickDuration = 0U;
    bool m_reinitRequired = true;
    bool m_connectRequired = true;
    bool m_connected = false;
    bool m_subscribeRequired = true;
    bool m_subscribed = false;
    bool m_firstConnect = true;
    bool m_disconnected = false;
};

State* asState(void* data)
{
    return reinterpret_cast<State*>(data);
}

std::ostream& infoLog(State* state)
{
    *(state->m_log) << "INFO: ";
    return *(state->m_log);
}

std::ostream& errorLog(State* state)
{
    *(state->m_log) << "ERROR: ";
    return *(state->m_log);
}

void nextTickProgramCb(void* data, unsigned duration)
{
    asState(data)->m_nextTickDuration = duration;
}

unsigned cancelNextTickWaitCb(void* data)
{
    auto diff = std::min(asState(data)->m_nextTickDuration, 1U);
    asState(data)->m_nextTickDuration -= diff;
    return diff;
}

void sendOutputDataCb([[maybe_unused]] void* data, [[maybe_unused]] const unsigned char* buf, unsigned bufLen)
{
    auto* state = asState(data);
    auto& out = infoLog(state);
    out << "Sending " << bufLen << " bytes: " << std::hex;
    std::copy_n(buf, bufLen, std::ostream_iterator<unsigned>(out, " "));
    out << std::dec << std::endl;
}

void brokerDisconnectReportCb(void* data, [[maybe_unused]] const CC_Mqtt5DisconnectInfo* info)
{
    auto* state = asState(data);
    infoLog(state) << "Broker disconnected" << std::endl;
    state->m_disconnected = true;
    state->m_reinitRequired = true;
    state->m_connectRequired = true;
    state->m_connected = false;
}

void messageReceivedReportCb([[maybe_unused]] void* data, [[maybe_unused]] const CC_Mqtt5MessageInfo* info)
{
    auto* state = asState(data);
    infoLog(state) << "Message Received!!!\n" << std::endl;
}

void errorLogCb([[maybe_unused]] void* data, const char* msg)
{
    auto* state = asState(data);
    errorLog(state) << msg << std::endl;
}

void connectCompleteCb(void* data, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5ConnectResponse* response)
{
    auto* state = asState(data);

    do {
        if (status != CC_Mqtt5AsyncOpStatus_Complete) {
            break;
        }

        assert(response != nullptr);
        if (CC_Mqtt5ReasonCode_Success != response->m_reasonCode) {
            break;
        }

        assert(cc_mqtt5_##NAME##client_is_connected(state->m_client));

        if (response->m_sessionPresent) {
            state->m_subscribeRequired = false;
            state->m_subscribed = false;
        }

        infoLog(state) << "Connected" << std::endl;
        state->m_connectRequired = false;
        state->m_connected = true;
        state->m_firstConnect = false;
        return;
    } while (false);

    state->m_connectRequired = true;
    state->m_connected = false;
    state->m_reinitRequired = true;    
}

void subscribeCompleteCb(void* data, [[maybe_unused]] CC_Mqtt5SubscribeHandle handle, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5SubscribeResponse* response)
{
    auto* state = asState(data);

    do {
        if (status != CC_Mqtt5AsyncOpStatus_Complete) {
            break;
        }

        assert(response != nullptr);
        bool allOk = true;
        for (auto idx = 0U; idx < response->m_reasonCodesCount; ++idx) {
            if (CC_Mqtt5ReasonCode_UnspecifiedError <= response->m_reasonCodes[idx]) {
                allOk = false;
                break;
            }
        }
        
        if (!allOk) {
            break;
        }

        infoLog(state) << "Subscribed" << std::endl;
        state->m_subscribed = true;

        return;
    } while (false);

    state->m_subscribeRequired = true;
    state->m_subscribed = false;
}

} // namespace 

int main([[maybe_unused]] int argc, [[maybe_unused]] const char* argv[]) 
{

    std::ofstream log("/tmp/afl_fuzz.log", std::ios_base::app);
    if (!log) {
        std::cerr << "Failed to open log file" << std::endl;
        return -1;
    }

    AflFuzzClientPtr client(cc_mqtt5_##NAME##client_alloc());
    State state;
    state.m_client = client.get();
    state.m_log = &log;

    cc_mqtt5_##NAME##client_set_next_tick_program_callback(client.get(), &nextTickProgramCb, &state);
    cc_mqtt5_##NAME##client_set_cancel_next_tick_wait_callback(client.get(), &cancelNextTickWaitCb, &state);
    cc_mqtt5_##NAME##client_set_send_output_data_callback(client.get(), &sendOutputDataCb, &state);
    cc_mqtt5_##NAME##client_set_broker_disconnect_report_callback(client.get(), &brokerDisconnectReportCb, &state);
    cc_mqtt5_##NAME##client_set_message_received_report_callback(client.get(), &messageReceivedReportCb, &state);
    cc_mqtt5_##NAME##client_set_error_log_callback(client.get(), &errorLogCb, &state);

    sync();

    CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
    std::uint8_t buf[BufSize] = {0};
    for (auto i = 0U; i < IterCount; ++i) {
        infoLog(&state) << "Iteration " << i << std::endl;
        if (state.m_reinitRequired) {
            state.m_reinitRequired = false;
            state.m_disconnected = false;
            ec = cc_mqtt5_##NAME##client_init(client.get());
            assert(ec == CC_Mqtt5ErrorCode_Success);
            if (ec != CC_Mqtt5ErrorCode_Success) {
                exit(-1);
            }
        }

        assert(cc_mqtt5_##NAME##client_is_initialized(client.get()));

        do {
            if (state.m_connectRequired) {
                state.m_connected = false;

                infoLog(&state) << "Connecting..." << std::endl;
                
                auto connect = cc_mqtt5_##NAME##client_connect_prepare(client.get(), &ec);
                assert(connect != nullptr);
                assert(ec == CC_Mqtt5ErrorCode_Success);
                if (connect == nullptr) {
                    exit(-1);
                }

                CC_Mqtt5ConnectBasicConfig basicConfig;
                cc_mqtt5_##NAME##client_connect_init_config_basic(&basicConfig);
                basicConfig.m_clientId = "some_id";
                basicConfig.m_cleanStart = state.m_firstConnect;
                
                ec = cc_mqtt5_##NAME##client_connect_config_basic(connect, &basicConfig);
                assert(ec == CC_Mqtt5ErrorCode_Success);
                if (ec != CC_Mqtt5ErrorCode_Success) {
                    exit(-1);
                }   

                // TODO: extra configuration

                ec = cc_mqtt5_##NAME##client_connect_send(connect, &connectCompleteCb, &state);
                assert(ec == CC_Mqtt5ErrorCode_Success);
                if (ec != CC_Mqtt5ErrorCode_Success) {
                    exit(-1);
                }   

                state.m_connectRequired = false;
                break;              
            }

            if (!cc_mqtt5_##NAME##client_is_connected(client.get())) {
                infoLog(&state) << "Not connected yet..." << std::endl;
                assert(!state.m_connected);
                break;
            }

            assert(state.m_connected);

            if (state.m_subscribeRequired) {
                state.m_subscribed = false;

                infoLog(&state) << "Subscribing..." << std::endl;

                auto subscribe = cc_mqtt5_##NAME##client_subscribe_prepare(client.get(), &ec);
                assert(subscribe != nullptr);
                assert(ec == CC_Mqtt5ErrorCode_Success);
                if (subscribe == nullptr) {
                    exit(-1);
                }     

                CC_Mqtt5SubscribeTopicConfig config;
                cc_mqtt5_##NAME##client_subscribe_init_config_topic(&config);
                config.m_topic = "#";

                ec = cc_mqtt5_##NAME##client_subscribe_config_topic(subscribe, &config);
                assert(ec == CC_Mqtt5ErrorCode_Success);
                if (ec != CC_Mqtt5ErrorCode_Success) {
                    exit(-1);
                }  

                ec = cc_mqtt5_##NAME##client_subscribe_send(subscribe, &subscribeCompleteCb, &state);
                assert(ec == CC_Mqtt5ErrorCode_Success);
                if (ec != CC_Mqtt5ErrorCode_Success) {
                    exit(-1);
                }   

                state.m_subscribeRequired = false;
                break;                                
            }

        } while (false);

        auto len = read(0, buf, BufSize);
        bool noMoreRead = (len <= 0);
        len = std::max(len, static_cast<decltype(len)>(0));
        auto& out = infoLog(&state);
        out << "Read " << len << " bytes: " << std::hex;
        std::copy_n(buf, len, std::ostream_iterator<unsigned>(out, " "));
        out << std::dec << std::endl;

        auto dataPtr = &buf[0];
        auto dataLen = static_cast<std::size_t>(len);
        if (!state.m_inData.empty()) {
            state.m_inData.insert(state.m_inData.end(), dataPtr, dataPtr + dataLen);
            static const auto MaxLen = std::numeric_limits<unsigned>::max();

            if (MaxLen < state.m_inData.size()) {
                state.m_inData.erase(state.m_inData.begin(), state.m_inData.begin() + (state.m_inData.size() - MaxLen));
            }

            dataPtr = state.m_inData.data();
            dataLen = state.m_inData.size();
        }

        using Interface = cc_mqtt5::Message<>;
        using IdAndFlagsField = cc_mqtt5::frame::Frame<Interface>::Layer_idAndFlags::Field;
        using SizeField = cc_mqtt5::frame::Frame<Interface>::Layer_size::Field;

        static constexpr auto MinLen = IdAndFlagsField::minLength() + SizeField::minLength();
        if (dataLen < MinLen) {
            if (noMoreRead) {
                infoLog(&state) << "Insufficient data in buffer: " << dataLen << std::endl;
                break;
            }

            continue;
        }

        auto iter = dataPtr;
        std::advance(iter, IdAndFlagsField::minLength());

        auto processLen = dataLen;
        SizeField sizeField;
        auto es = sizeField.read(iter, dataLen - IdAndFlagsField::minLength());
        if (es == comms::ErrorStatus::Success) {
            auto msgLen = IdAndFlagsField::minLength() + sizeField.length() + sizeField.getValue();
            processLen = std::min(dataLen, msgLen);
        }

        infoLog(&state) << "Processing " << processLen << " out of " << dataLen << " bytes..." << std::endl;
        auto consumed = cc_mqtt5_##NAME##client_process_data(client.get(), dataPtr, static_cast<unsigned>(processLen));
        infoLog(&state) << "Consumed: " << consumed << std::endl;

        assert((consumed > 0U) || (!state.m_disconnected));

        if ((consumed == 0U) && noMoreRead) {
            infoLog(&state) << "No data consumed and no more input" << std::endl;
            break;
        }

        if (dataLen <= consumed) {
            state.m_inData.clear();
            continue;
        }

        if (state.m_inData.empty()) {
            state.m_inData.assign(dataPtr + consumed, dataPtr + dataLen);
            infoLog(&state) << "Keeping " << state.m_inData.size() << " bytes for the next iteration" << std::endl;
            continue;
        }

        state.m_inData.erase(state.m_inData.begin(), state.m_inData.begin() + consumed);
        infoLog(&state) << "Keeping " << state.m_inData.size() << " bytes for the next iteration" << std::endl;
    }

    infoLog(&state) << "------------------------------------------------" << std::endl;
    return 0U;
}