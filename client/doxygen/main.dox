/// @mainpage MQTT5 Client Library
/// @tableofcontents
/// @section cc_mqtt5_client_overview Overview
/// The <b>MQTT5 Client Library</b> from the <a href="https://commschamp.github.io/">CommsChampion Ecosystem</a>
/// provides simple, asynchronous, non-blocking,
/// and easy to use interface to operate MQTT5 client. The library doesn't
/// make any assumption on the system it is running on, as well as on the type
/// of I/O link being used to communicate its data to the MQTT5 capable broker.
///
/// It is a responsibility of the calling application to manage network connectivity
/// as well as measure time required for the correct operation of the MQTT5 protocol.
///
/// @section cc_mqtt5_client_header Header
/// To use this <b>MQTT5 Client Library</b> use the following include statement:
/// @code
/// #include "cc_mqtt5_client/client.h"
/// @endcode
///
/// @section cc_mqtt5_client_allocation Client Allocation
/// The library supports multiple independent MQTT5 client sessions. The
/// allocation of data structures relevant to a single client is performed
/// using cc_mqtt5_client_new() function.
/// @code
/// CC_Mqtt5ClientHandle client = cc_mqtt5_client_new();
/// @endcode
/// All other functions are client specific, the receive the returned handle
/// as their first parameter.
///
/// When work with allocated client is complete, it must be freed using
/// cc_mqtt5_client_free() function.
/// @code
/// cc_mqtt5_client_free(client);
/// @endcode
///
/// When working with C++ it is advised to use a smart pointer with a custom deleter.
/// @code
/// struct MyDeleter
/// {
///     void operator()(CC_Mqtt5Client* ptr)
///     {
///         ::cc_mqtt5_client_free(ptr);
///     }
/// };
///
/// using MyClientPtr = std::unique_ptr<CC_Mqtt5Client, MyDeleter>;
///
/// MyClientPtr clientPtr(::cc_mqtt5_client_new());
/// CC_Mqtt5ClientHandle client = clientPtr.get();
/// @endcode
///
/// @section cc_mqtt5_client_callbacks "Must Have" Callbacks Registration
/// In order to properly function the library requires setting several callbacks.
///
/// @subsection cc_mqtt5_client_callbacks_send_data Sending Data To Broker
/// To client application must assign a callback for the library to be able to send
/// binary data out to the connected broker.
/// @code
/// void my_send_data_cb(void* data, const unsigned char* buf, unsigned bufLen)
/// {
///     ... /* send requested buffer to the broker */
/// }
///
/// cc_mqtt5_client_set_send_output_data_callback(client, &my_send_data_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5SendOutputDataCb callback function definition.
///
/// @subsection cc_mqtt5_client_callbacks_broker_disconnect Reporting Unsolicited Broker Disconnection
/// The client application must assign a callback for the library to report
/// discovered broker disconnection.
/// @code
/// void my_broker_disconnected_cb(void* data, const CC_Mqtt5DisconnectInfo* info)
/// {
///     ... /* handle broker disconnection */
///     if (info != NULL) {
///         ... /* Access disconnection report details */
///     }
/// }
///
/// cc_mqtt5_client_set_broker_disconnect_report_callback(client, &my_broker_disconnected_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5BrokerDisconnectReportCb callback function definition.
///
/// @subsection cc_mqtt5_client_callbacks_message Reporting Received Message
/// The client application must assign a callback for the library to report
/// messages received from the broker.
/// @code
/// void my_message_received_cb(void* data, const CC_Mqtt5MessageInfo* info)
/// {
///     ... /* handle the received message */
/// }
///
/// cc_mqtt5_client_set_message_received_report_callback(client, &my_message_received_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5MessageReceivedReportCb callback function definition.
///
/// @section cc_mqtt5_client_time Time Measurement
/// For the correct operation of the MQTT5 client side of the protocol, the library
/// requires an ability to measure time. This responsibility is delegated to the
/// application.
///
/// The easiest (although not very efficient or very precise) method is to periodically (say every 20ms - 50ms)
/// call the @b cc_mqtt5_client_tick() function reporting the amount of elapsed milliseconds:
/// @code
/// cc_mqtt5_client_tick(client, 50U);
/// @endcode
/// The library will check if some inner timer has expired and may initiate some
/// response via invocation one of the registered callbacks.
///
/// Another (recommended) method is to register a callback so the library
/// may request the time measurement from the application, and when the
/// requested time expires, the application is expected to call the
/// @b cc_mqtt5_client_tick() function reporting amount of elapsed milliseconds.
/// @code
/// void my_tick_program_cb(void* data, unsigned ms)
/// {
///     ... /* program timer to expire in "ms" milliseconds and invoke cc_mqtt5_client_tick() when it does. */
/// }
///
/// cc_mqtt5_client_set_next_tick_program_callback(client, &my_tick_program_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5NextTickProgramCb callback function definition.
///
/// In case of callback approach for time measurement is chosen, another callback function
/// (in addition to the @b cc_mqtt5_client_set_next_tick_program_callback()) to
/// allow interruption of the previously programmed tick wait must also to be registered.
/// @code
/// unsigned my_cancel_tick_program_cb(void* data)
/// {
///     ...
///     return ... /* return amount of elapsed milliseconds since last tick program */
/// }
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5CancelNextTickWaitCb callback function definition.
///
/// Usually the callbacks of canceling the previously programmed tick and programming a new one
/// will be invoked as a side effect of other events, like report of the incoming data or
/// client requesting to perform one of the available operations.
///
/// @section cc_mqtt5_client_log Error Logging
/// Sometimes the library may exhibit unexpected behaviour, like rejecting some of the parameters.
/// To allow getting extra guidance information of what went wrong it is possible to register
/// optional error logging callback.
/// @code
/// void my_error_log_cb(void* data, const char* msg)
/// {
///     printf("ERROR: %s\n", msg);
/// }
///
/// cc_mqtt5_client_set_error_log_callback(client, &my_error_log_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5ErrorLogCb callback function definition.
///
/// @section cc_mqtt5_client_init Client (Re)Initialization
/// After all the necessary callbacks have been set, it is necessary for the application to
/// invoke @b cc_mqtt5_client_init() function to allow all other subsequent operations.
/// The function checks that all the necessary callbacks have been set and reinitializes internal
/// data structures.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_init(client);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong, not all callbacks are set */
/// }
/// @endcode
///
/// Also when broker disconnection is @ref cc_mqtt5_client_callbacks_broker_disconnect "reported",
/// it is necessary to perform re-initialization of the library to be able to re-connect
/// to the broker and continue operation.
///
/// @b IMPORTANT: According to the MQTT5 specification, when broker disconnection is reported, the
/// client needs to close network connection. It is a responsibility of the application to do so.
///
/// In other words, after the broker disconnection is reported the application is responsible to
/// perform the following steps:
/// @li Close the existing network connection.
/// @li Re-establish new network connection to the broker.
/// @li Re-initialize the client library by invoking @b cc_mqtt5_client_init() function.
///
/// All previously registered callbacks configuration persists and doesn't need to be
/// performed between the re-initialization requests.
///
/// To check whether the client has gone through the initialization procedure or still
/// needs to be (re)-initialized, the @b cc_mqtt5_client_is_initialized() function
/// can be used.
/// @code
/// if (!cc_mqtt5_client_is_initialized(client)) {
///     CC_Mqtt5ErrorCode ec = cc_mqtt5_client_init(client);
///     ...
/// }
/// @endcode
///
/// @section cc_mqtt5_client_concepts Operating Concepts
/// The library abstracts away multiple MQTT5 protocol based "operations". Every such operation
/// has multiple stages:
/// @li @b prepare - The operation is "allocated" and relevant handle is returned.
/// @li @b configure - Apply one or multiple configurations to the prepared operation.
/// @li @b send - Send the configured operation message to the broker.
///
/// During the @b send stage the application is expected to provide the callback to
/// report to the application when the operation is complete.
///
/// After the @b send stage the handle returned in the @b prepare stage can be discarded
/// (no explicit de-allocation is needed / supported), although it is still valid and can be used
/// to @b cancel the operation. Note that in case the appropriate message has already be
/// @b sent to the broker, cancelling the outstanding operation can be dangerous. When
/// broker sends a response and client is not expecting it any more, unexpected
/// behaviour (like treating the unexpected message as "protocol error" and disconnecting
/// from the broker) may happen.
///
/// In case something went wrong during the @b configure stage, it is possible to de-allocate
/// the prepared operation using the @b cancel request.
///
/// @section cc_mqtt5_client_response_timeout Default Response Timeout
/// After sending any operation request to the broker, the client library has to allow
/// some time for the broker to process the request. If it takes too much time, the
/// client must report that operation has failed via the set callback. By default the client
/// library allows 2 seconds for such response to arrive. Changing this default value
/// is possible using the @b cc_mqtt5_client_set_default_response_timeout() function,
/// and retrieving of the currently configured value can be done using the
/// @b cc_mqtt5_client_get_default_response_timeout() function.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_set_default_response_timeout(client, 3000 /* in ms */);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
///
/// @section cc_mqtt5_client_connect Connecting to Broker
///
