/// @mainpage MQTT5 Client Library
/// @tableofcontents
/// @section cc_mqtt5_client_overview Overview
/// The <b>MQTT5 Client Library</b> from the <a href="https://commschamp.github.io/">CommsChampion Ecosystem</a>
/// provides simple, asynchronous, non-blocking,
/// and easy to use interface to operate MQTT5 client. The library doesn't
/// make any assumption on the system it is running on, as well as on the type
/// of I/O link being used to communicate its data to the MQTT5 capable broker.
///
/// It is a responsibility of the calling application to manage network connectivity
/// as well as measure time required for the correct operation of the MQTT5 protocol.
///
/// The library allows the application to have a full control over the raw data for
/// any extra analysis and/or manipulation, such as encryption.
///
/// @section cc_mqtt5_client_header Header
/// To use this <b>MQTT5 Client Library</b> use the following include statement:
/// @code
/// #include "cc_mqtt5_client/client.h"
/// @endcode
///
/// @section cc_mqtt5_client_allocation Client Allocation
/// The library supports multiple independent MQTT5 client sessions. The
/// allocation of data structures relevant to a single client is performed
/// using cc_mqtt5_client_new() function.
/// @code
/// CC_Mqtt5ClientHandle client = cc_mqtt5_client_new();
/// @endcode
/// All other functions are client specific, the receive the returned handle
/// as their first parameter.
///
/// When work with allocated client is complete, it must be freed using
/// cc_mqtt5_client_free() function.
/// @code
/// cc_mqtt5_client_free(client);
/// @endcode
///
/// When working with C++ it is advised to use a smart pointer with a custom deleter.
/// @code
/// struct MyDeleter
/// {
///     void operator()(CC_Mqtt5Client* ptr)
///     {
///         ::cc_mqtt5_client_free(ptr);
///     }
/// };
///
/// using MyClientPtr = std::unique_ptr<CC_Mqtt5Client, MyDeleter>;
///
/// MyClientPtr clientPtr(::cc_mqtt5_client_new());
/// CC_Mqtt5ClientHandle client = clientPtr.get();
/// @endcode
///
/// @section cc_mqtt5_client_callbacks "Must Have" Callbacks Registration
/// In order to properly function the library requires setting several callbacks.
///
/// @subsection cc_mqtt5_client_callbacks_send_data Sending Data To Broker
/// To client application must assign a callback for the library to be able to send
/// binary data out to the connected broker.
/// @code
/// void my_send_data_cb(void* data, const unsigned char* buf, unsigned bufLen)
/// {
///     ... /* send requested buffer to the broker */
/// }
///
/// cc_mqtt5_client_set_send_output_data_callback(client, &my_send_data_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5SendOutputDataCb callback function definition.
///
/// @subsection cc_mqtt5_client_callbacks_broker_disconnect Reporting Unsolicited Broker Disconnection
/// The client application must assign a callback for the library to report
/// discovered broker disconnection.
/// @code
/// void my_broker_disconnected_cb(void* data, const CC_Mqtt5DisconnectInfo* info)
/// {
///     ... /* handle broker disconnection */
///     if (info != NULL) {
///         ... /* Access disconnection report details */
///     }
/// }
///
/// cc_mqtt5_client_set_broker_disconnect_report_callback(client, &my_broker_disconnected_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5BrokerDisconnectReportCb callback function definition.
///
/// @subsection cc_mqtt5_client_callbacks_message Reporting Received Message
/// The client application must assign a callback for the library to report
/// messages received from the broker.
/// @code
/// void my_message_received_cb(void* data, const CC_Mqtt5MessageInfo* info)
/// {
///     ... /* handle the received message */
/// }
///
/// cc_mqtt5_client_set_message_received_report_callback(client, &my_message_received_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5MessageReceivedReportCb callback function definition.
///
/// @section cc_mqtt5_client_time Time Measurement
/// For the correct operation of the MQTT5 client side of the protocol, the library
/// requires an ability to measure time. This responsibility is delegated to the
/// application.
///
/// The easiest (although not very efficient or very precise) method is to periodically (say every 20ms - 50ms)
/// call the @b cc_mqtt5_client_tick() function reporting the amount of elapsed milliseconds:
/// @code
/// cc_mqtt5_client_tick(client, 50U);
/// @endcode
/// The library will check if some inner timer has expired and may initiate some
/// response via invocation one of the registered callbacks.
///
/// Another (recommended) method is to register a callback so the library
/// may request the time measurement from the application, and when the
/// requested time expires, the application is expected to call the
/// @b cc_mqtt5_client_tick() function reporting amount of elapsed milliseconds.
/// @code
/// void my_tick_program_cb(void* data, unsigned ms)
/// {
///     ... /* program timer to expire in "ms" milliseconds and invoke cc_mqtt5_client_tick() when it does. */
/// }
///
/// cc_mqtt5_client_set_next_tick_program_callback(client, &my_tick_program_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5NextTickProgramCb callback function definition.
///
/// In case of callback approach for time measurement is chosen, another callback function
/// (in addition to the @b cc_mqtt5_client_set_next_tick_program_callback()) to
/// allow interruption of the previously programmed tick wait must also to be registered.
/// @code
/// unsigned my_cancel_tick_program_cb(void* data)
/// {
///     ...
///     return ... /* return amount of elapsed milliseconds since last tick program */
/// }
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5CancelNextTickWaitCb callback function definition.
///
/// Usually the callbacks of canceling the previously programmed tick and programming a new one
/// will be invoked as a side effect of other events, like report of the incoming data or
/// client requesting to perform one of the available operations.
///
/// @section cc_mqtt5_client_log Error Logging
/// Sometimes the library may exhibit unexpected behaviour, like rejecting some of the parameters.
/// To allow getting extra guidance information of what went wrong it is possible to register
/// optional error logging callback.
/// @code
/// void my_error_log_cb(void* data, const char* msg)
/// {
///     printf("ERROR: %s\n", msg);
/// }
///
/// cc_mqtt5_client_set_error_log_callback(client, &my_error_log_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5ErrorLogCb callback function definition.
///
/// @section cc_mqtt5_client_init Client (Re)Initialization
/// After all the necessary callbacks have been set, it is necessary for the application to
/// invoke @b cc_mqtt5_client_init() function to allow all other subsequent operations.
/// The function checks that all the necessary callbacks have been set and reinitializes internal
/// data structures.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_init(client);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong, not all callbacks are set */
/// }
/// @endcode
///
/// Also when broker disconnection is @ref cc_mqtt5_client_callbacks_broker_disconnect "reported",
/// it is necessary to perform re-initialization of the library to be able to re-connect
/// to the broker and continue operation.
///
/// @b IMPORTANT: According to the MQTT5 specification, when broker disconnection is reported, the
/// client needs to close network connection. It is a responsibility of the application to do so.
///
/// In other words, after the broker disconnection is reported the application is responsible to
/// perform the following steps:
/// @li Close the existing network connection.
/// @li Re-establish new network connection to the broker.
/// @li Re-initialize the client library by invoking @b cc_mqtt5_client_init() function.
///
/// All previously registered callbacks configuration persists and doesn't need to be
/// performed between the re-initialization requests.
///
/// To check whether the client has gone through the initialization procedure or still
/// needs to be (re)-initialized, the @b cc_mqtt5_client_is_initialized() function
/// can be used.
/// @code
/// if (!cc_mqtt5_client_is_initialized(client)) {
///     CC_Mqtt5ErrorCode ec = cc_mqtt5_client_init(client);
///     ...
/// }
/// @endcode
///
/// @section cc_mqtt5_client_data Reporting Incoming Data
/// It is the responsibility of the application to receive data from the broker
/// and report it to the library. The report is performed using the
/// @b cc_mqtt5_client_process_data() function.
/// @code
/// uint8_t buf[MAX_BUF_SIZE];
/// ... // Receive data into buffer
/// unsigned bufLen = ...; // Amount of received bytes in the buffer.
/// unsigned consumed = cc_mqtt5_client_process_data(client, buf, bufLen);
/// ... // Remove the first "consumed" bytes from the buffer and retain the rest
///     // until the new data chunk arrives.
/// @endcode
/// The application is responsible to maintain the input buffer. The
/// value returned from the @b cc_mqtt5_client_process_data() function reports
/// amount of consumed bytes. In case not all of the reported bytes were consumed
/// the application is responsible to keep them and report again with new appended
/// data when such arrives.
///
/// When new data chunk is reported the library may invoke several callbacks,
/// such as reporting received message, sending new data out, as well as canceling
/// the old and programming new tick timeout.
///
/// @section cc_mqtt5_client_concepts Operating Concepts
/// The library abstracts away multiple MQTT5 protocol based "operations". Every such operation
/// has multiple stages:
/// @li @b prepare - The operation is "allocated" and relevant handle is returned.
/// @li @b configure - Apply one or multiple configurations to the prepared operation.
/// @li @b send - Send the configured operation message to the broker.
///
/// During the @b send stage the application is expected to provide the callback to
/// report to the application when the operation is complete. The first parameter
/// of the callback is always "status" of the @ref CC_Mqtt5AsyncOpStatus type. It
/// indicates whether the operation was successfully complete. In addition to the
/// status it reports some extra information reported by the broker. The information
/// from the broker is available <b>if and only if</b> the status is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// The @b send stage function also returns @ref CC_Mqtt5ErrorCode value to indicate
/// whether the @b send was successfully performed. The provided callback will
/// be invoked <b>if and only if</b> the @b send returns @ref CC_Mqtt5ErrorCode_Success.
///
/// After the @b send stage the handle returned in the @b prepare stage can be discarded
/// (no explicit de-allocation is needed / supported) regardless of the return code.
/// After successful @b send the handle still remains valid until the callback invocation and can be used
/// to @b cancel the operation. Note that in case the appropriate message has already be
/// @b sent to the broker, cancelling the outstanding operation can be dangerous. When
/// broker sends a response and client is not expecting it any more, unexpected
/// behaviour (like treating the unexpected message as "protocol error" and disconnecting
/// from the broker) may happen.
///
/// In case something went wrong during the @b configure stage, it is possible to de-allocate
/// the prepared operation using the @b cancel request. After performing the @b cancel
/// stage the allocated handle is not longer valid.
///
/// @section cc_mqtt5_client_response_timeout Default Response Timeout
/// After sending any operation request to the broker, the client library has to allow
/// some time for the broker to process the request. If it takes too much time, the
/// client must report that operation has failed via the set callback. By default the client
/// library allows 2 seconds for such response to arrive. Changing this default value
/// is possible using the @b cc_mqtt5_client_set_default_response_timeout() function,
/// and retrieving of the currently configured value can be done using the
/// @b cc_mqtt5_client_get_default_response_timeout() function.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_set_default_response_timeout(client, 3000 /* in ms */);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
///
/// @section cc_mqtt5_client_connect Connecting to Broker
/// To connect to broker use "connect" operation.
///
/// @subsection cc_mqtt5_client_connect_prepare Preparing "Connect" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5ConnectHandle connect = cc_mqtt5_client_connect_prepare(client, &ec);
/// if (connect == NULL) {
///     printf("ERROR: Connect allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_connect_response_timeout Configuring "Connect" Response Timeout
/// When created the "connect" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_connect_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_connect_set_response_timeout(connect, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_connect_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_connect_basic Basic Configuration of "Connect" Operation
/// The "basic" configuration means no extra MQTT5 properties assigned to the message.
/// @code
/// CC_Mqtt5ConnectBasicConfig basicConfig;
///
/// // Assign default values to the "basicConfig"
/// cc_mqtt5_client_connect_init_config_basic(&basicConfig);
///
/// // Update the values if needed:
/// basicConfig.m_clientId = "some_client";
/// basicConfig.m_cleanStart = true;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Basic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// **IMPORTANT**: MQTT5 specification allows reconnection to the broker while
/// requesting previous session restoration (via "clean start" bit). To prevent
/// potential errors of the client and broker inner states being out of sync, the
/// @b first "connect" operation requires setting the @ref CC_Mqtt5ConnectBasicConfig::m_cleanStart
/// value to @b true. Otherwise the @ref CC_Mqtt5ErrorCode_BadParam error code
/// will be returned. Any subsequent reconnection attempts will allow
/// setting the value to @b false.
///
/// See also documentation of the @ref CC_Mqtt5ConnectBasicConfig structure.
///
/// @subsection cc_mqtt5_client_connect_will Will Configuration
/// @code
/// CC_Mqtt5ConnectWillConfig willConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_connect_init_config_will(&willConfig);
///
/// // Update values if needed
/// willConfig.m_topic = "some/topic";
/// willConfig.m_data = ...;
/// willConfig.m_dataLen = ...;
/// ...
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_will(connect, &willConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Will configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5ConnectWillConfig structure.
///
/// @b IMPORTANT: The @b cc_mqtt5_client_connect_config_will() function
/// mustn't be called more than once for a single "connect" operation. Otherwise
/// it may result in setting multiple will properties of the same type, which
/// is the "Protocol Error" according to the MQTT5 specification.
///
/// The MQTT5 specification allows adding several "User Properties" specific to
/// the will. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_connect_add_will_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_connect_add_will_user_prop(connect, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Will user property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_connect_extra Extra Properties Configuration
/// To add extra MQTT5 specific properties to the connection request use
/// @b cc_mqtt5_client_connect_config_extra() function.
/// @code
/// CC_Mqtt5ConnectExtraConfig extraConfig;
///
/// // Initialize the configuration structure to the default values
/// cc_mqtt5_client_connect_init_config_extra(&extraConfig);
///
/// // Assign necessary properties:
/// extraConfig.m_sessionExpiryInterval = 5;
/// extraConfig.m_topicAliasMaximum = 20;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_extra(connect, &extraConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Extra properties configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5ConnectExtraConfig structure.
///
/// @b IMPORTANT: The @b cc_mqtt5_client_connect_config_extra() function
/// mustn't be called more than once for a single "connect" operation. Otherwise
/// it may result in setting multiple properties of the same type, which
/// is the "Protocol Error" according to the MQTT5 specification.
///
/// @subsection cc_mqtt5_client_connect_auth Extended Authentication Handshake Configuration
/// In case the extended authentication handshake is needed use @b cc_mqtt5_client_connect_config_auth() function.
/// @code
/// CC_Mqtt5AuthErrorCode my_auth_handshake_cb(void* data, const CC_Mqtt5AuthInfo* authInfoIn, CC_Mqtt5AuthInfo* authInfoOut)
/// {
///     ... // Analyse authInfoIn
///     ... // Populate authInfoOut
///     if (auth_failed) {
///         return CC_Mqtt5AuthErrorCode_Disconnect; // terminate handshake with error
///     }
///
///     return CC_Mqtt5AuthErrorCode_Continue; // continue handshake
/// }
///
/// CC_Mqtt5AuthConfig authConfig;
///
/// // Initialize the configuration structure to the default values
/// cc_mqtt5_client_connect_init_config_auth(&authConfig);
///
/// // Assign all the necessary values
/// authConfig.m_authMethod = "some_method"
/// authConfig.m_authData = ...;
/// authConfig.m_authDataLen = ...;
/// authConfig.m_authCb = &my_auth_handshake_cb;
/// authConfig.m_authCbData = ...;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_auth(connect, &authConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Authentication handshake configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// During the "connect" operation, both client and the broker can exchange multiple
/// @b AUTH messages. When such message arrive the library will invoke provided
/// handshake callback. The responsibility of the callback is to analyze the
/// incoming authentication data and populate the response information. The client
/// can fail the handshake by returning the @ref CC_Mqtt5AuthErrorCode_Disconnect instead
/// of the @ref CC_Mqtt5AuthErrorCode_Continue.
///
/// @b IMPORTANT: The @b cc_mqtt5_client_connect_config_auth() function
/// mustn't be called more than once for a single "connect" operation. Otherwise
/// it may result in setting multiple properties of the same type, which
/// is the "Protocol Error" according to the MQTT5 specification.
///
/// @subsection cc_mqtt5_client_connect_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b CONNECT message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_connect_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_connect_add_user_prop(connect, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_connect_send Sending Connection Request
/// When all the necessary configurations are performed for the allocated "connect"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_connect_send() function.
/// @code
/// void my_connect_complete_cb(void* data, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5ConnectResponse* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The connection operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt5AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_connect_send(connect, &my_connect_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send connect request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "connect" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt5_client_connect_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_connect_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_connect_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// When the "connect" operation completion callback is invoked the reported
/// response information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @b IMPORTANT: The @ref CC_Mqtt5ConnectResponse "response" information from
/// the broker may report that some features on the broker side are disabled.
/// The library will reject any subsequent operation configuration which contradict
/// the broker's capabilities. For example, attempt to subscribe to the topic
/// containing wildcards, when the reported @ref CC_Mqtt5ConnectResponse::m_wildcardSubAvailable
/// is @b false, will be rejected with @ref CC_Mqtt5ErrorCode_BadParam.
///
/// Quote from the MQTT5 specification:
/// @code
/// If a Server sends a CONNACK packet containing a Reason code of 128 or greater
/// it MUST then close the Network Connection [MQTT-3.2.2-7]
/// @endcode
/// When the callback reporting the connection status is invoked, it is responsibility
/// of the application to check the @ref CC_Mqtt5ConnectResponse::m_reasonCode value.
/// If it's @ref CC_Mqtt5ReasonCode_UnspecifiedError or greater, the application
/// is responsible to close the network connection and go through the
/// @ref cc_mqtt5_client_init "re-initialization" process.
///
/// @subsection cc_mqtt5_client_connect_cancel Cancel the "Connect" Operation.
/// While the handle returned by the @b cc_mqtt5_client_connect_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_connect_cancel(connect);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel connect with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_connect_send() function was successfully
/// called before the @b cc_mqtt5_client_connect_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @subsection cc_mqtt5_client_connect_check Check The Library Remains Connected
/// At any time it is possible to check the internal state of the library of
/// whether it's properly connected to the broker.
/// @code
/// bool isConnected = cc_mqtt5_client_is_connected(client);
/// @endcode
///
/// @section cc_mqtt5_client_disconnect Disconnecting From Broker
/// To disconnect from broker use "disconnect" operation.
///
/// @subsection cc_mqtt5_client_disconnect_prepare Preparing "Disconnect" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5DisconnectHandle disconnect = cc_mqtt5_client_disconnect_prepare(client, &ec);
/// if (disconnect == NULL) {
///     printf("ERROR: Disconnect allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_disconnect_config Configuration of "Disconnect" Operation
/// The configuration of the "disconnect" operation is performed using a single
/// @b cc_mqtt5_client_diconnect_config() function.
/// @code
/// CC_Mqtt5DisconnectConfig config;
///
/// // Assign default values to the "config"
/// client_disconnect_init_config(&config);
///
/// // Update the values if needed:
/// config.m_reasonCode = CC_Mqtt5ReasonCode_DisconnectWithWill;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_diconnect_config(disconnect, &config);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Disconnect configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_disconnect_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b DISCONNECT message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_disconnect_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_disconnect_add_user_prop(disconnect, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_disconnect_send Sending Disconnection Request
/// When the necessary configuration is performed for the allocated "disconnect"
/// operation it can be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_disconnect_send() function.
/// @code
/// ec = cc_mqtt5_client_disconnect_send(disconnect);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send disconnect request with ec=%d\n", ec);
///     ...
///     return;
/// }
/// assert(!cc_mqtt5_client_is_connected(client)); // Expect immediate disconnection after the successful send
/// @endcode
/// @b NOTE that the @b cc_mqtt5_client_disconnect_send() function doesn't receive
/// any callback because there is no expected response to the @b DISCONNECT message
/// from the broker. The disconnection effect is immediate. The application is
/// expected to terminate the network connection and go through
/// @ref cc_mqtt5_client_init "re-initialization" process if necessary.
///
/// In case there are other asynchronous operations that hasn't been completed yet,
/// their completion callback is automatically invoked with @ref CC_Mqtt5AsyncOpStatus_Aborted
/// status.
///
/// @b IMPORTANT: In case of sending the explicit disconnection request the
/// @ref cc_mqtt5_client_callbacks_broker_disconnect "registered unsolicited disconnection callback"
/// is @b NOT invoked.
///
/// @subsection cc_mqtt5_client_disconnect_cancel Cancel the "Disconnect" Operation.
/// While the handle returned by the @b cc_mqtt5_client_disconnect_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_disconnect_cancel(disconnect);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel disconnect with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// @section cc_mqtt5_client_subscribe Subscribing to Receive Messages
/// To subscribe to receive incoming messages use "subscribe" operation.
/// The application can issue multiple "subscribe" operations in parallel.
///
/// @subsection cc_mqtt5_client_subscribe_prepare Preparing "Subscribe" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5SubscribeHandle subscribe = cc_mqtt5_client_subscribe_prepare(client, &ec);
/// if (subscribe == NULL) {
///     printf("ERROR: Subscribe allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_subscribe_response_timeout Configuring "Subscribe" Response Timeout
/// When created the "subscribe" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_subscribe_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_subscribe_set_response_timeout(subscribe, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_subscribe_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_subscribe_topic Topic Configuration
/// Single @b SUBSCRIBE message can carry multiple topic subscriptions. Use
/// @b cc_mqtt5_client_subscribe_config_topic() function to configure each
/// such subscription.
/// @code
/// CC_Mqtt5SubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_subscribe_init_config_topic(&topicConfig);
///
/// // Update values if needed
/// topicConfig.m_topic = "some/topic";
/// topicConfig.m_noLocal = true;
/// ...
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_subscribe_config_topic(subscribe, &topicConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Topic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5SubscribeTopicConfig structure.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used. That includes not submitting
/// topics with wildcards when the broker doesn't support them (see @ref CC_Mqtt5ConnectResponse),
/// or not using shared subscription for the same reason.
/// @code
/// ec = cc_mqtt5_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// @b NOTE that the configuration is global per client and not per "subscribe"
/// operation.
///
/// To retrieve the current configuration use @b cc_mqtt5_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @subsection cc_mqtt5_client_subscribe_extra Extra Properties Configuration
/// To add extra MQTT5 specific properties to the subscription request use
/// @b cc_mqtt5_client_subscribe_config_extra() function.
/// @code
/// CC_Mqtt5SubscribeExtraConfig extraConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_subscribe_init_config_extra(&extraConfig);
///
/// // Assign necessary properties:
/// extraConfig.m_subId = ...;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_subscribe_config_extra(subscribe, &extraConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Extra properties configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5SubscribeExtraConfig structure.
///
/// @b Note that explicitly initializing the @ref CC_Mqtt5SubscribeExtraConfig
/// configuration object is not really necessary, because it has only a single @ref CC_Mqtt5SubscribeExtraConfig::m_subId member,
/// which is going to be overwritten as part of the configuration. However, calling
/// the @b cc_mqtt5_client_subscribe_init_config_extra() is still recommended to make the
/// application's code future updates proof. Potentially the MQTT5 specification and as the
/// result this library can be updated by adding new property to the @ref
/// CC_Mqtt5SubscribeExtraConfig struct. Having the "unnecessary" call to the
/// @b cc_mqtt5_client_subscribe_init_config_extra() function makes sure
/// that newly added property gets initialized to the default value without
/// any need to update the application's code.
///
/// Also note that allocating and managing the "Subscription Identifier" property values is
/// completely application's responsibility. The broker is responsible to report
/// the assigned value when sending relevant message, and the client can use the
/// reported value for easier dispatching of the received message to appropriate
/// handling functionality.
///
/// @subsection cc_mqtt5_client_subscribe_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b SUBSCRIBE message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_subscribe_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_subscribe_add_user_prop(subscribe, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_subscribe_send Sending Subscription Request
/// When all the necessary configurations are performed for the allocated "subscribe"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_subscribe_send() function.
/// @code
/// void my_subscribe_complete_cb(void* data, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5SubscribeResponse* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The subscription operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt5AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_subscribe_send(subscribe, &my_subscribe_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send subscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "subscribe" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt5_client_subscribe_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_subscribe_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_subscribe_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// When the "subscribe" operation completion callback is invoked the reported
/// response information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @subsection cc_mqtt5_client_subscribe_cancel Cancel the "Subscribe" Operation.
/// While the handle returned by the @b cc_mqtt5_client_subscribe_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_subscribe_cancel(subscribe);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel subscribe with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_subscribe_send() function was successfully
/// called before the @b cc_mqtt5_client_subscribe_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @section cc_mqtt5_client_unsubscribe Unsubscribing from Message Reception
/// To unsubscribe from receiving incoming messages use "unsubscribe" operation.
/// The application can issue multiple "unsubscribe" operations in parallel.
///
/// @subsection cc_mqtt5_client_unsubscribe_prepare Preparing "Unsubscribe" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5UnsubscribeHandle unsubscribe = cc_mqtt5_client_unsubscribe_prepare(client, &ec);
/// if (unsubscribe == NULL) {
///     printf("ERROR: Unsubscribe allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_unsubscribe_response_timeout Configuring "Unsubscribe" Response Timeout
/// When created the "unsubscribe" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_unsubscribe_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_unsubscribe_set_response_timeout(unsubscribe, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_unsubscribe_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_unsubscribe_topic Topic Configuration
/// Single @b UNSUBSCRIBE message can carry multiple topic unsubscriptions. Use
/// @b cc_mqtt5_client_unsubscribe_config_topic() function to configure each
/// such unsubscription.
/// @code
/// CC_Mqtt5UnsubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_unsubscribe_init_config_topic(&topicConfig);
///
/// // Update values
/// topicConfig.m_topic = "some/topic";
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_unsubscribe_config_topic(unsubscribe, &topicConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Topic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UnsubscribeTopicConfig structure.
///
/// @b Note that explicitly initializing the @ref CC_Mqtt5UnsubscribeTopicConfig
/// configuration object is not really necessary, because it has only a single @ref CC_Mqtt5UnsubscribeTopicConfig::m_topic member,
/// which is going to be overwritten as part of the configuration. However, calling
/// the @b cc_mqtt5_client_unsubscribe_init_config_topic() is still recommended to make the
/// application's code future updates proof. Potentially the MQTT5 specification and as the
/// result this library can be updated by adding new fields to the @ref
/// CC_Mqtt5UnsubscribeTopicConfig struct. Having the "unnecessary" call to the
/// @b cc_mqtt5_client_unsubscribe_init_config_topic() function makes sure
/// that newly added field gets initialized to the default value without
/// any need to update the application's code.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used.
/// @code
/// ec = cc_mqtt5_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// @b NOTE that the configuration is global per client and not per "unsubscribe"
/// operation.
///
/// To retrieve the current configuration use @b cc_mqtt5_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @subsection cc_mqtt5_client_unsubscribe_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b UNSUBSCRIBE message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_unsubscribe_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_unsubscribe_add_user_prop(unsubscribe, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_unsubscribe_send Sending Unsubscription Request
/// When all the necessary configurations are performed for the allocated "unsubscribe"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_unsubscribe_send() function.
/// @code
/// void my_unsubscribe_complete_cb(void* data, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5UnsubscribeResponse* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The unsubscription operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt5AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_unsubscribe_send(unsubscribe, &my_unsubscribe_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send unsubscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "unsubscribe" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt5_client_unsubscribe_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_unsubscribe_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_unsubscribe_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// When the "unsubscribe" operation completion callback is invoked the reported
/// response information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @subsection cc_mqtt5_client_unsubscribe_cancel Cancel the "Unsubscribe" Operation.
/// While the handle returned by the @b cc_mqtt5_client_unsubscribe_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_unsubscribe_cancel(unsubscribe);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel unsubscribe with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_unsubscribe_send() function was successfully
/// called before the @b cc_mqtt5_client_unsubscribe_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @section cc_mqtt5_client_publish Publishing Messages
///
/// @section cc_mqtt5_client_receive Receiving Messages
///
/// @section cc_mqtt5_client_reauth Re-Authenticating
///
/// @section cc_mqtt5_client_unsolicited_disconnect Unsolicited Disconnection
///
/// @section cc_mqtt5_client_network_disconnect Network Disconnection
///
/// @section cc_mqtt5_client_thread_safety Thread Safety
