/// @mainpage MQTT5 Client Library
/// @tableofcontents
/// @section cc_mqtt5_client_overview Overview
/// The <b>MQTT5 Client Library</b> from the <a href="https://commschamp.github.io/">CommsChampion Ecosystem</a>
/// provides simple, asynchronous, non-blocking,
/// and easy to use interface to operate MQTT5 client. The library doesn't
/// make any assumption on the system it is running on, as well as on the type
/// of I/O link being used to communicate its data to the MQTT5 capable broker.
///
/// It is a responsibility of the calling application to manage network connectivity
/// as well as measure time required for the correct operation of the MQTT5 protocol.
///
/// The library allows the application to have a full control over the raw data for
/// any extra analysis and/or manipulation, such as encryption.
///
/// @section cc_mqtt5_client_version Version of the Library
/// The version is of the library applicable to this documentation is defined in 
/// the @ref common.h "cc_mqtt5_client/common.h" file using the following defines:
/// @li @ref CC_MQTT5_CLIENT_MAJOR_VERSION
/// @li @ref CC_MQTT5_CLIENT_MINOR_VERSION
/// @li @ref CC_MQTT5_CLIENT_PATCH_VERSION
///
/// @section cc_mqtt5_client_header Header
/// To use this <b>MQTT5 Client Library</b> use the following single include statement:
/// @code
/// #include "cc_mqtt5_client/client.h"
/// @endcode
///
/// @section cc_mqtt5_client_allocation Client Allocation
/// The library supports multiple independent MQTT5 client sessions. The
/// allocation of data structures relevant to a single client is performed
/// using cc_mqtt5_client_alloc() function.
/// @code
/// CC_Mqtt5ClientHandle client = cc_mqtt5_client_alloc();
/// @endcode
/// All other functions are client specific, the receive the returned handle
/// as their first parameter.
///
/// When work with allocated client is complete, it must be freed using
/// cc_mqtt5_client_free() function.
/// @code
/// cc_mqtt5_client_free(client);
/// @endcode
///
/// When working with C++ it is advised to use a smart pointer with a custom deleter.
/// @code
/// struct MyDeleter
/// {
///     void operator()(CC_Mqtt5Client* ptr)
///     {
///         ::cc_mqtt5_client_free(ptr);
///     }
/// };
///
/// using MyClientPtr = std::unique_ptr<CC_Mqtt5Client, MyDeleter>;
///
/// MyClientPtr clientPtr(::cc_mqtt5_client_alloc());
/// CC_Mqtt5ClientHandle client = clientPtr.get();
/// @endcode
///
/// @b IMPORTANT: The function @b cc_mqtt5_client_free() must @b NOT
/// be called from within a callback. Use next event loop iteration.
///
/// @section cc_mqtt5_client_callbacks "Must Have" Callbacks Registration
/// In order to properly function the library requires setting several callbacks.
///
/// @subsection cc_mqtt5_client_callbacks_send_data Sending Data To Broker
/// To client application must assign a callback for the library to be able to send
/// binary data out to the connected broker.
/// @code
/// void my_send_data_cb(void* data, const unsigned char* buf, unsigned bufLen)
/// {
///     ... /* send requested buffer to the broker */
/// }
///
/// cc_mqtt5_client_set_send_output_data_callback(client, &my_send_data_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5SendOutputDataCb callback function definition.
///
/// @subsection cc_mqtt5_client_callbacks_broker_disconnect Reporting Unsolicited Broker Disconnection
/// The client application must assign a callback for the library to report
/// discovered broker disconnection.
/// @code
/// void my_broker_disconnected_cb(void* data, const CC_Mqtt5DisconnectInfo* info)
/// {
///     ... /* handle broker disconnection */
///     if (info != NULL) {
///         ... /* Access disconnection report details */
///     }
/// }
///
/// cc_mqtt5_client_set_broker_disconnect_report_callback(client, &my_broker_disconnected_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5BrokerDisconnectReportCb callback function definition.
///
/// @subsection cc_mqtt5_client_callbacks_message Reporting Received Message
/// The client application must assign a callback for the library to report
/// messages received from the broker.
/// @code
/// void my_message_received_cb(void* data, const CC_Mqtt5MessageInfo* info)
/// {
///     ... /* handle the received message */
/// }
///
/// cc_mqtt5_client_set_message_received_report_callback(client, &my_message_received_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5MessageReceivedReportCb callback function definition.
///
/// @section cc_mqtt5_client_time Time Measurement
/// For the correct operation of the MQTT5 client side of the protocol, the library
/// requires an ability to measure time. This responsibility is delegated to the
/// application.
///
/// The easiest (although not very efficient or very precise) method is to periodically (say every 20ms - 50ms)
/// call the @b cc_mqtt5_client_tick() function reporting the amount of elapsed milliseconds:
/// @code
/// cc_mqtt5_client_tick(client, 50U);
/// @endcode
/// The library will check if some inner timer has expired and may initiate some
/// response via invocation one of the registered callbacks.
///
/// Another (recommended) method is to register a callback so the library
/// may request the time measurement from the application, and when the
/// requested time expires, the application is expected to call the
/// @b cc_mqtt5_client_tick() function reporting amount of elapsed milliseconds.
/// @code
/// void my_tick_program_cb(void* data, unsigned ms)
/// {
///     ... 
///     cc_mqtt5_client_tick(client, ms); 
/// }
///
/// cc_mqtt5_client_set_next_tick_program_callback(client, &my_tick_program_cb, data);
/// @endcode
/// It is allowed to invoke the @b cc_mqtt5_client_tick() before the actual requested timeout has 
/// expired, just make sure that the correct amount of elapsed milliseconds is reported. When 
/// the @b cc_mqtt5_client_tick() is invoked, it is assumed that the previously requested tick
/// programming has been cancelled and the registered callback may be invoked again from within the
/// @b cc_mqtt5_client_tick().
///
/// See also the documentation of the @ref CC_Mqtt5NextTickProgramCb callback function definition.
///
/// In case of callback approach for time measurement is chosen, another callback function
/// (in addition to the @b cc_mqtt5_client_set_next_tick_program_callback()) to
/// allow interruption of the previously programmed tick wait must also to be registered.
/// @code
/// unsigned my_cancel_tick_program_cb(void* data)
/// {
///     ...
///     return ... /* return amount of elapsed milliseconds since last tick program */
/// }
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5CancelNextTickWaitCb callback function definition.
///
/// Usually the callbacks of canceling the previously programmed tick and programming a new one
/// will be invoked as a side effect of other events, like report of the incoming data or
/// client requesting to perform one of the available operations.
///
/// @section cc_mqtt5_client_log Error Logging
/// Sometimes the library may exhibit unexpected behaviour, like rejecting some of the parameters.
/// To allow getting extra guidance information of what went wrong it is possible to register
/// optional error logging callback.
/// @code
/// void my_error_log_cb(void* data, const char* msg)
/// {
///     printf("ERROR: %s\n", msg);
/// }
///
/// cc_mqtt5_client_set_error_log_callback(client, &my_error_log_cb, data);
/// @endcode
/// See also the documentation of the @ref CC_Mqtt5ErrorLogCb callback function definition.
///
/// @section cc_mqtt5_client_init Client (Re)Initialization
/// After all the necessary callbacks have been set, it is necessary for the application to
/// invoke @b cc_mqtt5_client_init() function to allow all other subsequent operations.
/// The function checks that all the necessary callbacks have been set and reinitializes internal
/// data structures.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_init(client);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong, not all callbacks are set */
/// }
/// @endcode
///
/// Also when broker disconnection is @ref cc_mqtt5_client_callbacks_broker_disconnect "reported",
/// it is necessary to perform re-initialization of the library to be able to re-connect
/// to the broker and continue operation.
///
/// @b IMPORTANT: According to the MQTT5 specification, when broker disconnection is reported, the
/// client needs to close network connection. It is a responsibility of the application to do so.
///
/// In other words, after the broker disconnection is reported the application is responsible to
/// perform the following steps:
/// @li Close the existing network connection.
/// @li Re-establish new network connection to the broker.
/// @li Re-initialize the client library by invoking @b cc_mqtt5_client_init() function.
///
/// All previously registered callbacks configuration persists and doesn't need to be
/// performed between the re-initialization requests.
///
/// @b NOTE that the @b cc_mqtt5_client_init() cannot be called from within a callback.
/// For example, if the broker disconnection is reported via @ref cc_mqtt5_client_callbacks_broker_disconnect "callback"
/// then the @ref cc_mqtt5_client_init "re-initialization" cannot be executed right away.
/// It needs to be postponed until the next event loop iteration.
///
/// To check whether the client has gone through the initialization procedure or still
/// needs to be (re)-initialized, the @b cc_mqtt5_client_is_initialized() function
/// can be used.
/// @code
/// if (!cc_mqtt5_client_is_initialized(client)) {
///     CC_Mqtt5ErrorCode ec = cc_mqtt5_client_init(client);
///     ...
/// }
/// @endcode
///
/// @section cc_mqtt5_client_data Reporting Incoming Data
/// It is the responsibility of the application to receive data from the broker
/// and report it to the library. The report is performed using the
/// @b cc_mqtt5_client_process_data() function.
/// @code
/// uint8_t buf[MAX_BUF_SIZE];
/// ... // Receive data into buffer
/// unsigned bufLen = ...; // Amount of received bytes in the buffer.
/// unsigned consumed = cc_mqtt5_client_process_data(client, buf, bufLen);
/// ... // Remove the first "consumed" bytes from the buffer and retain the rest
///     // until the new data chunk arrives.
/// @endcode
/// The application is responsible to maintain the input buffer. The
/// value returned from the @b cc_mqtt5_client_process_data() function reports
/// amount of consumed bytes. In case not all of the reported bytes were consumed
/// the application is responsible to keep them and report again with new appended
/// data when such arrives.
///
/// When new data chunk is reported the library may invoke several callbacks,
/// such as reporting received message, sending new data out, as well as canceling
/// the old and programming new tick timeout.
///
/// @section cc_mqtt5_client_concepts Operating Concepts
/// The library abstracts away multiple MQTT5 protocol based "operations". Every such operation
/// has multiple stages:
/// @li @b prepare - The operation is "allocated" and relevant handle is returned.
/// @li @b configure - Apply one or multiple configurations to the prepared operation.
/// @li @b send - Send the configured operation message to the broker.
///
/// During the @b send stage the application is expected to provide the callback to
/// report to the application when the operation is complete. The second parameter
/// of the callback is always "status" of the @ref CC_Mqtt5AsyncOpStatus type. It
/// indicates whether the operation was successfully complete. In addition to the
/// status it reports some extra information reported by the broker. The information
/// from the broker is available <b>if and only if</b> the status is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// The @b send stage function also returns @ref CC_Mqtt5ErrorCode value to indicate
/// whether the @b send was successfully performed. The provided callback will
/// be invoked <b>if and only if</b> the @b send returns @ref CC_Mqtt5ErrorCode_Success.
///
/// After the @b send stage the handle returned in the @b prepare stage can be discarded
/// (no explicit de-allocation is needed / supported) regardless of the return code.
/// After successful @b send the handle still remains valid until the callback invocation and can be used
/// to @b cancel the operation. Note that in case the appropriate message has already be
/// @b sent to the broker, cancelling the outstanding operation can be dangerous. When
/// broker sends a response and client is not expecting it any more, unexpected
/// behaviour (like treating the unexpected message as "protocol error" and disconnecting
/// from the broker) may happen.
///
/// In case something went wrong during the @b configure stage, it is possible to de-allocate
/// the prepared operation using the @b cancel request. After performing the @b cancel
/// stage the allocated handle is no longer valid.
///
/// @section cc_mqtt5_client_response_timeout Default Response Timeout
/// After sending any operation request to the broker, the client library has to allow
/// some time for the broker to process the request. If it takes too much time, the
/// client must report that operation has failed via the set callback. By default the client
/// library allows 2 seconds for such response to arrive. Changing this default value
/// is possible using the @b cc_mqtt5_client_set_default_response_timeout() function,
/// and retrieving of the currently configured value can be done using the
/// @b cc_mqtt5_client_get_default_response_timeout() function.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_set_default_response_timeout(client, 3000 /* in ms */);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
///
/// @section cc_mqtt5_client_connect Connecting to Broker
/// To connect to broker use @ref connect "connect" operation.
///
/// @subsection cc_mqtt5_client_connect_prepare Preparing "Connect" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5ConnectHandle connect = cc_mqtt5_client_connect_prepare(client, &ec);
/// if (connect == NULL) {
///     printf("ERROR: Connect allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_connect_response_timeout Configuring "Connect" Response Timeout
/// When created, the "connect" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_connect_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_connect_set_response_timeout(connect, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_connect_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_connect_basic Basic Configuration of "Connect" Operation
/// The "basic" configuration means no extra MQTT5 properties assigned to the message.
/// @code
/// CC_Mqtt5ConnectBasicConfig basicConfig;
///
/// // Assign default values to the "basicConfig"
/// cc_mqtt5_client_connect_init_config_basic(&basicConfig);
///
/// // Update the values if needed:
/// basicConfig.m_clientId = "some_client";
/// basicConfig.m_cleanStart = true;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Basic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// **IMPORTANT**: MQTT5 specification allows reconnection to the broker while
/// requesting previous session restoration (via "clean start" bit). To prevent
/// potential errors of the client and broker inner states being out of sync, the
/// @b first "connect" operation requires setting the @ref CC_Mqtt5ConnectBasicConfig::m_cleanStart
/// value to @b true. Otherwise the @ref CC_Mqtt5ErrorCode_BadParam error code
/// will be returned. Any subsequent reconnection attempts will allow
/// setting the value to @b false.
///
/// See also documentation of the @ref CC_Mqtt5ConnectBasicConfig structure.
///
/// @subsection cc_mqtt5_client_connect_will Will Configuration
/// To perform will configuration use the @b cc_mqtt5_client_connect_config_will() function.
/// @code
/// CC_Mqtt5ConnectWillConfig willConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_connect_init_config_will(&willConfig);
///
/// // Update values if needed
/// willConfig.m_topic = "some/topic";
/// willConfig.m_data = ...;
/// willConfig.m_dataLen = ...;
/// ...
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_will(connect, &willConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Will configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5ConnectWillConfig structure.
///
/// @b IMPORTANT: The @b cc_mqtt5_client_connect_config_will() function
/// mustn't be called more than once for a single "connect" operation. Otherwise
/// it may result in setting multiple will properties of the same type, which
/// is the "Protocol Error" according to the MQTT5 specification.
///
/// The MQTT5 specification allows adding several "User Properties" specific to
/// the will. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_connect_add_will_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_connect_add_will_user_prop(connect, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Will user property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_connect_extra Extra Properties Configuration
/// To add extra MQTT5 specific properties to the connection request use
/// @b cc_mqtt5_client_connect_config_extra() function.
/// @code
/// CC_Mqtt5ConnectExtraConfig extraConfig;
///
/// // Initialize the configuration structure to the default values
/// cc_mqtt5_client_connect_init_config_extra(&extraConfig);
///
/// // Assign necessary properties:
/// extraConfig.m_sessionExpiryInterval = 5;
/// extraConfig.m_topicAliasMaximum = 20;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_extra(connect, &extraConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Extra properties configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5ConnectExtraConfig structure.
///
/// @b IMPORTANT: The @b cc_mqtt5_client_connect_config_extra() function
/// mustn't be called more than once for a single "connect" operation. Otherwise
/// it may result in setting multiple properties of the same type, which
/// is the "Protocol Error" according to the MQTT5 specification.
///
/// @subsection cc_mqtt5_client_connect_auth Extended Authentication Handshake Configuration
/// In case the extended authentication handshake is needed use @b cc_mqtt5_client_connect_config_auth() function.
/// @code
/// CC_Mqtt5AuthErrorCode my_auth_handshake_cb(void* data, const CC_Mqtt5AuthInfo* authInfoIn, CC_Mqtt5AuthInfo* authInfoOut)
/// {
///     ... // Analyse authInfoIn
///     if (auth_failed) {
///         return CC_Mqtt5AuthErrorCode_Disconnect; // terminate handshake with error
///     }
///
///     ... // Populate authInfoOut
///     return CC_Mqtt5AuthErrorCode_Continue; // continue handshake
/// }
///
/// CC_Mqtt5AuthConfig authConfig;
///
/// // Initialize the configuration structure to the default values
/// cc_mqtt5_client_connect_init_config_auth(&authConfig);
///
/// // Assign all the necessary values
/// authConfig.m_authMethod = "some_method"
/// authConfig.m_authData = ...;
/// authConfig.m_authDataLen = ...;
/// authConfig.m_authCb = &my_auth_handshake_cb;
/// authConfig.m_authCbData = ...;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_connect_config_auth(connect, &authConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Authentication handshake configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// During the "connect" operation, both client and the broker can exchange multiple
/// @b AUTH messages. When such message arrive the library will invoke provided
/// handshake callback. The responsibility of the callback is to analyze the
/// incoming authentication data and populate the response information. The client
/// can fail the handshake by returning the @ref CC_Mqtt5AuthErrorCode_Disconnect instead
/// of the @ref CC_Mqtt5AuthErrorCode_Continue.
///
/// When client side fails the authentication, the @b DISCONNECT message is
/// sent to the broker and "connect" operation callback (see @ref cc_mqtt5_client_connect_send below)
/// will be invoked with @ref CC_Mqtt5AsyncOpStatus_Aborted as status report. The
/// broker disconnection report @ref cc_mqtt5_client_callbacks_broker_disconnect "callback"
/// will @b NOT be invoked, because the connection hasn't really happened yet.
///
/// @b IMPORTANT: The @b cc_mqtt5_client_connect_config_auth() function
/// mustn't be called more than once for a single "connect" operation. Otherwise
/// it may result in setting multiple properties of the same type, which
/// is the "Protocol Error" according to the MQTT5 specification.
///
/// @subsection cc_mqtt5_client_connect_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b CONNECT message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_connect_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_connect_add_user_prop(connect, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_connect_send Sending Connection Request
/// When all the necessary configurations are performed for the allocated "connect"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_connect_send() function.
/// @code
/// void my_connect_complete_cb(void* data, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5ConnectResponse* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The connection operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt5AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_connect_send(connect, &my_connect_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send connect request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "connect" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt5_client_connect_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_connect_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_connect_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// When the "connect" operation completion callback is invoked the reported
/// "response" information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @b NOTE that only single "connect" operation is allowed at a time, any attempt to
/// prepare a new one via @b cc_mqtt5_client_connect_prepare() will be rejected
/// until the "connect" operation completion callback is invoked or
/// the operation is @ref cc_mqtt5_client_connect_cancel "cancelled".
///
/// @b IMPORTANT: The @ref CC_Mqtt5ConnectResponse "response" information from
/// the broker may report that some features on the broker side are disabled.
/// The library will reject any subsequent operation configuration which contradict
/// the broker's capabilities. For example, attempt to subscribe to the topic
/// containing wildcards, when the reported @ref CC_Mqtt5ConnectResponse::m_wildcardSubAvailable
/// is @b false, will be rejected with @ref CC_Mqtt5ErrorCode_BadParam.
///
/// Quote from the MQTT5 specification:
/// @code
/// If a Server sends a CONNACK packet containing a Reason code of 128 or greater
/// it MUST then close the Network Connection [MQTT-3.2.2-7]
/// @endcode
/// When the callback reporting the connection status is invoked, it is responsibility
/// of the application to check the @ref CC_Mqtt5ConnectResponse::m_reasonCode value.
/// If it's @ref CC_Mqtt5ReasonCode_UnspecifiedError or greater, the application
/// is responsible to close the network connection and go through the
/// @ref cc_mqtt5_client_init "re-initialization" process. The same should be
/// done when the "connect" operation is not properly completed, i.e. the
/// reported status is @b NOT @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @subsection cc_mqtt5_client_connect_cancel Cancel the "Connect" Operation.
/// While the handle returned by the @b cc_mqtt5_client_connect_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_connect_cancel(connect);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel connect with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_connect_send() function was successfully
/// called before the @b cc_mqtt5_client_connect_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @subsection cc_mqtt5_client_connect_check Check The Library Remains Connected
/// At any time it is possible to check the internal state of the library of
/// whether it's properly connected to the broker.
/// @code
/// bool isConnected = cc_mqtt5_client_is_connected(client);
/// @endcode
///
/// @section cc_mqtt5_client_disconnect Disconnecting From Broker
/// To intentionally disconnect from broker use @ref disconnect "disconnect" operation. The
/// unsolicited disconnection from the broker is described in ref
/// @ref cc_mqtt5_client_unsolicited_disconnect section below.
///
/// @subsection cc_mqtt5_client_disconnect_prepare Preparing "Disconnect" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5DisconnectHandle disconnect = cc_mqtt5_client_disconnect_prepare(client, &ec);
/// if (disconnect == NULL) {
///     printf("ERROR: Disconnect allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_disconnect_config Configuration of "Disconnect" Operation
/// The configuration of the "disconnect" operation is performed using a single
/// @b cc_mqtt5_client_disconnect_config() function.
/// @code
/// CC_Mqtt5DisconnectConfig config;
///
/// // Assign default values to the "config"
/// client_disconnect_init_config(&config);
///
/// // Update the values if needed:
/// config.m_reasonCode = CC_Mqtt5ReasonCode_DisconnectWithWill;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_disconnect_config(disconnect, &config);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Disconnect configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_disconnect_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b DISCONNECT message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_disconnect_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_disconnect_add_user_prop(disconnect, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_disconnect_send Sending Disconnection Request
/// When the necessary configuration is performed for the allocated "disconnect"
/// operation it can be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_disconnect_send() function.
/// @code
/// ec = cc_mqtt5_client_disconnect_send(disconnect);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send disconnect request with ec=%d\n", ec);
///     ...
///     return;
/// }
/// assert(!cc_mqtt5_client_is_connected(client)); // Expect immediate disconnection after the successful send
/// @endcode
/// @b NOTE that the @b cc_mqtt5_client_disconnect_send() function doesn't receive
/// any callback because there is no expected response to the @b DISCONNECT message
/// from the broker. The disconnection effect is immediate. The application is
/// expected to terminate the network connection and go through
/// @ref cc_mqtt5_client_init "re-initialization" process if necessary. The
/// handle returned by the @b cc_mqtt5_client_disconnect_prepare() must be discarded.
///
/// In case there are other asynchronous operations that hasn't been completed yet,
/// their completion callback is automatically invoked with @ref CC_Mqtt5AsyncOpStatus_Aborted
/// status.
///
/// @b IMPORTANT: In case of sending the explicit disconnection request the
/// @ref cc_mqtt5_client_callbacks_broker_disconnect "registered unsolicited disconnection callback"
/// is @b NOT invoked.
///
/// @subsection cc_mqtt5_client_disconnect_cancel Cancel the "Disconnect" Operation.
/// While the handle returned by the @b cc_mqtt5_client_disconnect_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_disconnect_cancel(disconnect);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel disconnect with ec=%d\n", ec);
///     ...
/// }
/// @endcode
///
/// @section cc_mqtt5_client_subscribe Subscribing to Receive Messages
/// To subscribe to receive incoming messages use @ref subscribe "subscribe" operation.
/// The application can issue multiple "subscribe" operations in parallel.
///
/// @subsection cc_mqtt5_client_subscribe_prepare Preparing "Subscribe" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5SubscribeHandle subscribe = cc_mqtt5_client_subscribe_prepare(client, &ec);
/// if (subscribe == NULL) {
///     printf("ERROR: Subscribe allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_subscribe_response_timeout Configuring "Subscribe" Response Timeout
/// When created, the "subscribe" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_subscribe_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_subscribe_set_response_timeout(subscribe, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_subscribe_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_subscribe_topic Topic Configuration
/// Single @b SUBSCRIBE message can carry multiple topic subscriptions. Use
/// separate @b cc_mqtt5_client_subscribe_config_topic() function invocation to configure each
/// such subscription.
/// @code
/// CC_Mqtt5SubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_subscribe_init_config_topic(&topicConfig);
///
/// // Update values if needed
/// topicConfig.m_topic = "some/topic";
/// topicConfig.m_noLocal = true;
/// ...
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_subscribe_config_topic(subscribe, &topicConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Topic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5SubscribeTopicConfig structure.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used. That includes not submitting
/// topics with wildcards when the broker doesn't support them (see @ref CC_Mqtt5ConnectResponse),
/// or not using shared subscription for the same reason.
/// @code
/// ec = cc_mqtt5_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// @b NOTE that the configuration is global per client and not per "subscribe"
/// operation.
///
/// Also @b note that the same function controls the verification of the
/// "publish" topic format.
///
/// To retrieve the current configuration use @b cc_mqtt5_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @subsection cc_mqtt5_client_subscribe_extra Extra Properties Configuration
/// To add extra MQTT5 specific properties to the subscription request use
/// @b cc_mqtt5_client_subscribe_config_extra() function.
/// @code
/// CC_Mqtt5SubscribeExtraConfig extraConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_subscribe_init_config_extra(&extraConfig);
///
/// // Assign necessary properties:
/// extraConfig.m_subId = ...;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_subscribe_config_extra(subscribe, &extraConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Extra properties configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5SubscribeExtraConfig structure.
///
/// @b Note that explicitly initializing the @ref CC_Mqtt5SubscribeExtraConfig
/// configuration object is not really necessary, because it has only a single @ref CC_Mqtt5SubscribeExtraConfig::m_subId member,
/// which is going to be overwritten as part of the configuration. However, calling
/// the @b cc_mqtt5_client_subscribe_init_config_extra() is still recommended to make the
/// application's code future updates proof. Potentially the MQTT5 specification and as the
/// result this library can be updated by adding new property to the @ref
/// CC_Mqtt5SubscribeExtraConfig struct. Having the "unnecessary" call to the
/// @b cc_mqtt5_client_subscribe_init_config_extra() function makes sure
/// that newly added property gets initialized to the default value without
/// any need to update the application's code.
///
/// Also note that allocating and managing the "Subscription Identifier" property values is
/// completely application's responsibility. The broker is responsible to report
/// the assigned value when sending relevant message, and the client can use the
/// reported value for easier dispatching of the received message to appropriate
/// handling functionality.
///
/// @subsection cc_mqtt5_client_subscribe_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b SUBSCRIBE message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_subscribe_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_subscribe_add_user_prop(subscribe, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_subscribe_send Sending Subscription Request
/// When all the necessary configurations are performed for the allocated "subscribe"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_subscribe_send() function.
/// @code
/// void my_subscribe_complete_cb(void* data, CC_Mqtt5SubscribeHandle handle, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5SubscribeResponse* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The subscription operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt5AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_subscribe_send(subscribe, &my_subscribe_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send subscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "subscribe" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt5_client_subscribe_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_subscribe_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_subscribe_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// Note that the callback function receives the "subscribe" operation handle as
/// its second parameter. Although the handle is already invalid and cannot be
/// used in any other function, it allows the application to identify the
/// original "subscribe" request if multiple have been issued in parallel
/// and use the same callback function for all of them.
///
/// When the "subscribe" operation completion callback is invoked the reported
/// "response" information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @subsection cc_mqtt5_client_subscribe_cancel Cancel the "Subscribe" Operation.
/// While the handle returned by the @b cc_mqtt5_client_subscribe_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_subscribe_cancel(subscribe);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel subscribe with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_subscribe_send() function was successfully
/// called before the @b cc_mqtt5_client_subscribe_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @section cc_mqtt5_client_unsubscribe Unsubscribing from Message Reception
/// To unsubscribe from receiving incoming messages use @ref unsubscribe "unsubscribe" operation.
/// The application can issue multiple "unsubscribe" operations in parallel.
///
/// @subsection cc_mqtt5_client_unsubscribe_prepare Preparing "Unsubscribe" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5UnsubscribeHandle unsubscribe = cc_mqtt5_client_unsubscribe_prepare(client, &ec);
/// if (unsubscribe == NULL) {
///     printf("ERROR: Unsubscribe allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_unsubscribe_response_timeout Configuring "Unsubscribe" Response Timeout
/// When created, the "unsubscribe" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_unsubscribe_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_unsubscribe_set_response_timeout(unsubscribe, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_unsubscribe_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_unsubscribe_topic Topic Configuration
/// Single @b UNSUBSCRIBE message can carry multiple topic unsubscriptions. Use
/// @b cc_mqtt5_client_unsubscribe_config_topic() function to configure each
/// such unsubscription.
/// @code
/// CC_Mqtt5UnsubscribeTopicConfig topicConfig;
///
/// // Assign default values to the configuration
/// cc_mqtt5_client_unsubscribe_init_config_topic(&topicConfig);
///
/// // Update values
/// topicConfig.m_topic = "some/topic";
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_unsubscribe_config_topic(unsubscribe, &topicConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Topic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UnsubscribeTopicConfig structure.
///
/// @b Note that explicitly initializing the @ref CC_Mqtt5UnsubscribeTopicConfig
/// configuration object is not really necessary, because it has only a single @ref CC_Mqtt5UnsubscribeTopicConfig::m_topic member,
/// which is going to be overwritten as part of the configuration. However, calling
/// the @b cc_mqtt5_client_unsubscribe_init_config_topic() is still recommended to make the
/// application's code future updates proof. Potentially the MQTT5 specification and as the
/// result this library can be updated by adding new fields to the @ref
/// CC_Mqtt5UnsubscribeTopicConfig struct. Having the "unnecessary" call to the
/// @b cc_mqtt5_client_unsubscribe_init_config_topic() function makes sure
/// that newly added field gets initialized to the default value without
/// any need to update the application's code.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used.
/// @code
/// ec = cc_mqtt5_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// @b NOTE that the configuration is global per client and not per "unsubscribe"
/// operation.
///
/// To retrieve the current configuration use @b cc_mqtt5_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @subsection cc_mqtt5_client_unsubscribe_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b UNSUBSCRIBE message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_unsubscribe_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_unsubscribe_add_user_prop(unsubscribe, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_unsubscribe_send Sending Unsubscription Request
/// When all the necessary configurations are performed for the allocated "unsubscribe"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_unsubscribe_send() function.
/// @code
/// void my_unsubscribe_complete_cb(void* data, CC_Mqtt5UnsubscribeHandle handle, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5UnsubscribeResponse* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The unsubscription operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt5AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_unsubscribe_send(unsubscribe, &my_unsubscribe_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send unsubscribe request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "unsubscribe" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt5_client_unsubscribe_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_unsubscribe_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_unsubscribe_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// Note that the callback function receives the "unsubscribe" operation handle as
/// its second parameter. Although the handle is already invalid and cannot be
/// used in any other function, it allows the application to identify the
/// original "unsubscribe" request if multiple have been issued in parallel
/// and use the same callback function for all of them.
///
/// When the "unsubscribe" operation completion callback is invoked the reported
/// "response" information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @subsection cc_mqtt5_client_unsubscribe_cancel Cancel the "Unsubscribe" Operation.
/// While the handle returned by the @b cc_mqtt5_client_unsubscribe_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_unsubscribe_cancel(unsubscribe);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel unsubscribe with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_unsubscribe_send() function was successfully
/// called before the @b cc_mqtt5_client_unsubscribe_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @section cc_mqtt5_client_publish Publishing Messages
/// To publish messages to the broker use @ref publish "publish" operation.
///
/// @subsection cc_mqtt5_client_publish_prepare Preparing "Publish" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5PublishHandle publish = cc_mqtt5_client_publish_prepare(client, &ec);
/// if (publish == NULL) {
///     printf("ERROR: Publish allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_publish_response_timeout Configuring "Publish" Response Timeout
/// When publishing messages with QoS value @ref CC_Mqtt5QoS_AtLeastOnceDelivery or above, the
/// response from the broker is expected.
///
/// When created, the "publish" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_publish_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_publish_set_response_timeout(publish, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_publish_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_publish_resend Configuring "Publish" Re-Send Attempts
/// The MQTT5 specification has a mechanism of insured delivery of the published
/// message to the broker. In the case of not 100% reliable connection the messages
/// can get lost and needs to be re-sent. The default amount of re-sends is @b 2, i.e.
/// when the first send is not acknowledged by the broker, it is tried again with
/// @b DUP flag is set in the @b PUBLISH message. When the second attempt is
/// not acknowledged, then the publish operation is terminated with appropriate
/// status report. It is possible to change the default by using
/// @b cc_mqtt5_client_publish_set_resend_attempts() function.
/// @code
/// ec = cc_mqtt5_client_publish_set_resend_attempts(publish, 3);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured resend attempts number use the @b cc_mqtt5_client_publish_get_resend_attempts() function.
///
/// @subsection cc_mqtt5_client_publish_basic Basic Configuration of "Publish" Operation
/// The "basic" configuration means no extra MQTT5 properties assigned to the message, with
/// one small exception of using topic alias (covered @ref cc_mqtt5_client_publish_alias "below" as a separate subject).
/// @code
/// CC_Mqtt5PublishBasicConfig basicConfig;
///
/// // Assign default values to the "basicConfig"
/// cc_mqtt5_client_publish_init_config_basic(&basicConfig);
///
/// // Update the required values
/// basicConfig.m_topic = "some_topic";
/// basicConfig.m_data = &some_buf[0];
/// basicConfig.m_dataLen = ...;
/// basicConfig.m_qos = ...;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_publish_config_basic(publish, &basicConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Basic configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5PublishBasicConfig structure.
///
/// By default the library will perform the analysis of the submitted topic format and
/// reject it if topic format is incorrect. However, for performance reasons
/// it is possible to disable such verification when client application
/// ensures that no invalid topics are used.
/// @code
/// ec = cc_mqtt5_client_set_verify_outgoing_topic_enabled(client, false);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something is wrong */
/// }
/// @endcode
/// To retrieve the current configuration use the @b cc_mqtt5_client_get_verify_outgoing_topic_enabled()
/// function.
///
/// @b NOTE that the configuration is global per client and not per "publish"
/// operation.
///
/// Also @b note that the same function controls the verification of the
/// "subscribe" and "unsubscribe" topic filter format.
///
/// @subsection cc_mqtt5_client_publish_extra Extra Properties Configuration
/// To add extra MQTT5 specific properties to the publish request use
/// @b cc_mqtt5_client_publish_config_extra() function.
/// @code
/// CC_Mqtt5PublishExtraConfig extraConfig;
///
/// // Initialize the configuration structure to the default values
/// cc_mqtt5_client_publish_init_config_extra(&extraConfig);
///
/// // Assign necessary properties:
/// extraConfig.m_messageExpiryInterval = 5;
/// extraConfig.m_format = CC_Mqtt5PayloadFormat_Utf8;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_publish_config_extra(publish, &extraConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Extra properties configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5PublishExtraConfig structure.
///
/// @subsection cc_mqtt5_client_publish_user_prop Adding "User Properties"
/// The MQTT5 specification allows attaching any number of the "User Properties" to
/// the @b PUBLISH message. The library allows such assignment using multiple invocations of
/// the @b cc_mqtt5_client_publish_add_user_prop() function.
/// @code
/// CC_Mqtt5UserProp prop;
/// prop.m_key = "some_key";
/// prop.m_value = "some_value";
/// ec = cc_mqtt5_client_publish_add_user_prop(publish, &prop);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: User property configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// See also documentation of the @ref CC_Mqtt5UserProp structure.
///
/// @subsection cc_mqtt5_client_publish_send Sending Publish Request
/// When all the necessary configurations are performed for the allocated "publish"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_publish_send() function.
/// @code
/// void my_publish_complete_cb(void* data, CC_Mqtt5PublishHandle handle, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5PublishResponse* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The publish operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" may be NULL when there is no response from broker
///     // applicable when QoS is CC_Mqtt5QoS_AtMostOnceDelivery.
///     if (response == NULL) {
///         return;
///     }
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_publish_send(publish, &my_publish_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send publish request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "publish" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The callback pointer can also be @b NULL. In such case the completion of the
/// publish operation is silent.
///
/// When QoS value is @ref CC_Mqtt5QoS_AtMostOnceDelivery (see
/// the @ref cc_mqtt5_client_publish_basic "basic" configuration), there
/// is no broker response to wait for and the callback is invoked right away
/// after sending the serialized data.
///
/// The handle returned by the @b cc_mqtt5_client_publish_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_publish_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_publish_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// Note that the callback function receives the "publish" operation handle as
/// its second parameter. Although the handle is already invalid and cannot be
/// used in any other function, it allows the application to identify the
/// original "publish" request if multiple have been issued in parallel
/// and use the same callback function for all of them.
///
/// When the "publish" operation completion callback is invoked the reported
/// "response" information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// When the callback reporting the publish status is invoked, it is responsibility
/// of the application to check the @ref CC_Mqtt5PublishResponse::m_reasonCode value.
/// If it's @ref CC_Mqtt5ReasonCode_UnspecifiedError or greater means the "publish"
/// operation wasn't successful.
///
/// @subsection cc_mqtt5_client_publish_cancel Cancel the "Publish" Operation.
/// While the handle returned by the @b cc_mqtt5_client_publish_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_publish_cancel(publish);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel publish with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_publish_send() function was successfully
/// called before the @b cc_mqtt5_client_publish_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// @subsection cc_mqtt5_client_publish_alias Using Topic Alias
/// The MQTT5 specification allows usage of the numeric topic aliases to
/// be able to reduce amount of bytes per publish. In order for the library to start
/// using topic aliases, they need to be allocated (registered) using the
/// @b cc_mqtt5_client_pub_topic_alias_alloc() function.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_pub_topic_alias_alloc(client, "some_topic", 2 /* qos0RegsCount */);
/// @endcode
/// Note that the broker reports maximum amount of allowed topic aliases
/// in its response to the "connect" request via the @ref CC_Mqtt5ConnectResponse::m_topicAliasMax
/// ("Topic Alias Maximum" property).
/// It means that the allocation of the topic aliases is allowed only after the
/// successful "connect" operation.
///
/// Also note that the topic aliases are not part of the session state. Every
/// @ref cc_mqtt5_client_init "re-initialization" (which is required for
/// @ref cc_mqtt5_client_connect "re-connection") all the previously allocated
/// topic aliases get cleared in the internal data structures and they need to
/// be allocated again.
///
/// The last parameter passed to the @b cc_mqtt5_client_pub_topic_alias_alloc() function
/// is used to specify how many times the topic alias is reported to the broker
/// alongside the topic string in the "publish" operation when only QoS0 publishes are used.
/// For the QoS1 and QoS2
/// "publish" operations there is an acknowledgement message from the broker indicating
/// that the topic alias is received and known to the broker. However,  when QoS0 only
/// publishes are performed, the reception of the topic alias registration request
/// by the broker is not ensured. Also the MQTT5 specification explicitly states
/// that it is "Protocol Error" to use unknown topic alias.
/// @code{.unparsed}
/// If the PUBLISH packet contains a Topic Alias, the receiver processes it as follows:
/// ...
/// 3) If the receiver does not already have a mapping for this Topic Alias
///     a) If the packet has a zero length Topic Name field it is a Protocol Error and the receiver uses
///        DISCONNECT with Reason Code of 0x82 (Protocol Error) as described in section 4.13.
/// @endcode
/// Based on the said above, it can be prone to unexpected protocol error disconnection to use
/// single QoS0 publish message to report topic alias to the broker, so the last
/// parameter of the @b cc_mqtt5_client_pub_topic_alias_alloc() function indicates how
/// many times the topic alias needs to be reported to the broker alongside the
/// topic string itself before client is allowed to send topic alias only without
/// the topic string. However if any QoS1 or QoS2 messages are successfully published
/// to the broker with the same topic alias, then all the subsequent QoS0 message
/// will use topic alias without the topic string.
///
/// To stop using topic alias for the specific topic, use @b cc_mqtt5_client_pub_topic_alias_free()
/// function to free the allocated alias.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_pub_topic_alias_free(client, "some_topic");
/// @endcode
///
/// To inquire how many topic aliases have already been allocated, use the
/// @b cc_mqtt5_client_pub_topic_alias_count() function.
/// @code
/// unsigned count = cc_mqtt5_client_pub_topic_alias_count(client);
/// @endcode
///
/// To check whether a topic alias is allocated for specific topic use
/// the @b cc_mqtt5_client_pub_topic_alias_is_allocated() function.
/// @code
/// bool allocated = cc_mqtt5_client_pub_topic_alias_is_allocated(client, "some_topic");
/// @endcode
///
/// Once the topic alias is successfully allocated, the @ref cc_mqtt5_client_publish_basic "basic"
/// configuration of the "publish" operation allows control of whether and how to use
/// topic alias via the @ref CC_Mqtt5PublishBasicConfig::m_topicAliasPref data member.
///
/// @li @ref CC_Mqtt5TopicAliasPreference_UseAliasIfAvailable - Default value, allows usage of the topic alias
///     if such is available and it's up to the library to choose whether to send topic alias alone or
///     in conjunction with the topic string itself.
/// @li @ref CC_Mqtt5TopicAliasPreference_ForceAliasOnly - Forces sending only the topic alias
///     without the topic string.
/// @li @ref CC_Mqtt5TopicAliasPreference_ForceTopicOnly - Forces sending only the topic string
///     without the topic alias even if such was allocated (registered).
/// @li @ref CC_Mqtt5TopicAliasPreference_ForceTopicWithAlias - Forces sending both topic
///     alias and topic string even if it is safe to send topic alias only.
///
/// @section cc_mqtt5_client_receive Receiving Messages
/// Right after the successful "connect" operation, the library starts expecting
/// the arrival of the new messages and reports it via the @ref cc_mqtt5_client_callbacks_message
/// "registered callback". <b>By default</b> the library monitors the topics the client
/// application @ref cc_mqtt5_client_subscribe "subscribed" to and does not
/// report "rogue" messages from the broker.
///
/// @b Note that only topics themselves
/// are monitored, and not the requested maximal @b QoS values. It means that if
/// application requested maximal @b QoS1 for a particular subscription, but the
/// broker sends message using the @b QoS2, the message is still going to be
/// reported to the application.
///
/// However, if the broker is trusted to do the right thing, i.e. fully comply to
/// the specification, it is possible to enable / disable the incoming topics check using the
/// @b cc_mqtt5_client_set_verify_incoming_msg_subscribed() for performance reasons.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_set_verify_incoming_msg_subscribed(client, false);
/// @endcode
/// To retrieve the current configuration use the @b cc_mqtt5_client_get_verify_incoming_msg_subscribed() function.
///
/// Similarly, the library also <b>by default</b> verifies the incoming topic format, that it doesn't contain
/// wildcard characters. To enable / disable such verification use the @b cc_mqtt5_client_set_verify_incoming_topic_enabled()
/// function.
/// @code
/// CC_Mqtt5ErrorCode ec = cc_mqtt5_client_set_verify_incoming_topic_enabled(client, false);
/// @endcode
/// To retrieve the current configuration use the @b cc_mqtt5_client_get_verify_incoming_topic_enabled() function.
///
/// The @b QoS2 publish operation initiated by the broker requires exchange of multiple messages
/// between the broker and the client. When the library responds with the @b PUBREC
/// message, the broker is expected to send @b PUBREL back. The library uses the
/// @ref cc_mqtt5_client_response_timeout configuration to measure the time frame
/// during which it allows the reception of the corresponding @b PUBREL message. If the latter doesn't
/// arrive in time, the whole @b PUBLISH request gets discarded and not
/// reported to the application.
///
/// @section cc_mqtt5_client_reauth Re-Authenticating
/// The MQTT5 specification allows performing re-authentication after the successful
/// @ref cc_mqtt5_client_connect "\"connect\"" operation using the same authentication method.
/// To do so use the @ref reauth "reauth" operation.
///
/// @subsection cc_mqtt5_client_reauth_prepare Preparing "Rauth" Operation.
/// @code
/// CC_Mqtt5ErrorCode ec = CC_Mqtt5ErrorCode_Success;
/// CC_Mqtt5ReauthHandle reauth = cc_mqtt5_client_reauth_prepare(client, &ec);
/// if (reauth == NULL) {
///     printf("ERROR: Reauth allocation failed with ec=%d\n", ec);
/// }
/// @endcode
///
/// @subsection cc_mqtt5_client_reauth_response_timeout Configuring "Reauth" Response Timeout
/// When created, the "reauth" operation inherits the @ref cc_mqtt5_client_response_timeout
/// configuration. It can be changed for the allocated operation using the
/// @b cc_mqtt5_client_reauth_set_response_timeout() function.
/// @code
/// ec = cc_mqtt5_client_reauth_set_response_timeout(reauth, 1000);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     ... /* Something went wrong */
/// }
/// @endcode
/// To retrieve the configured response timeout use the @b cc_mqtt5_client_reauth_get_response_timeout() function.
///
/// @subsection cc_mqtt5_client_reauth_auth (Re)Authentication Handshake Configuration
/// To configure the re-authentication handshake use the @b cc_mqtt5_client_reauth_config_auth() function.
/// It is very similar to the @ref cc_mqtt5_client_connect_auth of the "connect" operation.
/// @code
/// CC_Mqtt5AuthErrorCode my_auth_handshake_cb(void* data, const CC_Mqtt5AuthInfo* authInfoIn, CC_Mqtt5AuthInfo* authInfoOut)
/// {
///     ... // Analyse authInfoIn
///     if (auth_failed) {
///         return CC_Mqtt5AuthErrorCode_Disconnect; // terminate handshake with error
///     }
///
///     ... // Populate authInfoOut
///     return CC_Mqtt5AuthErrorCode_Continue; // continue handshake
/// }
///
/// CC_Mqtt5AuthConfig authConfig;
///
/// // Initialize the configuration structure to the default values
/// cc_mqtt5_client_reauth_init_config_auth(&authConfig);
///
/// // Assign all the necessary values
/// authConfig.m_authMethod = "some_method"
/// authConfig.m_authData = ...;
/// authConfig.m_authDataLen = ...;
/// authConfig.m_authCb = &my_auth_handshake_cb;
/// authConfig.m_authCbData = ...;
///
/// // Perform the configuration
/// ec = cc_mqtt5_client_reauth_config_auth(reauth, &authConfig);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Re-Authentication handshake configuration failed with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// During the "reauth" operation, both client and the broker exchange multiple
/// @b AUTH messages. When such message arrive the library will invoke provided
/// handshake callback. The responsibility of the callback is to analyze the
/// incoming authentication data and populate the response information. The client
/// can fail the handshake by returning the @ref CC_Mqtt5AuthErrorCode_Disconnect instead
/// of the @ref CC_Mqtt5AuthErrorCode_Continue.
///
/// In case the application fails the re-authentication handshake by returning the
/// @ref CC_Mqtt5AuthErrorCode_Disconnect value library preforms the following steps:
/// @li Sends @b DISCONNECT message to the broker.
/// @li Invokes the operation completion callback (see @ref cc_mqtt5_client_reauth_send below)
///     with the @ref CC_Mqtt5AsyncOpStatus_Aborted "status" value report.
/// @li Invokes the @ref cc_mqtt5_client_callbacks_broker_disconnect "disconnection report callback"
///     to report disconnection from the broker. See also @ref cc_mqtt5_client_unsolicited_disconnect
///     section below for details on how to proceed after the callback invocation.
///
/// @b IMPORTANT: The @b cc_mqtt5_client_reauth_config_auth() function
/// mustn't be called more than once for a single "reauth" operation. Otherwise
/// it may result in setting multiple properties of the same type, which
/// is the "Protocol Error" according to the MQTT5 specification.
///
/// @subsection cc_mqtt5_client_reauth_send Sending Re-Authentication Request
/// When all the necessary configurations are performed for the allocated "reauth"
/// operation it can actually be sent to the broker. To initiate sending
/// use the @b cc_mqtt5_client_reauth_send() function.
/// @code
/// void my_reauth_complete_cb(void* data, CC_Mqtt5AsyncOpStatus status, const CC_Mqtt5AuthInfo* response)
/// {
///     if (status != CC_Mqtt5AsyncOpStatus_Complete) {
///         printf("ERROR: The connection operation has failed with status=%d\n", status);
///         ... // handle error.
///         return;
///     }
///
///     // "response" is not NULL when status is CC_Mqtt5AsyncOpStatus_Complete.
///     assert(response != NULL);
///     ... // Analyze response values.
/// }
///
/// ec = cc_mqtt5_client_reauth_send(reauth, &my_reauth_complete_cb, data);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to send reauth request with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// The provided callback will be invoked when the "reauth" operation is complete
/// <b> if and only if</b> the function returns @ref CC_Mqtt5ErrorCode_Success.
///
/// The handle returned by the @b cc_mqtt5_client_reauth_prepare() function
/// can be discarded (there is no free / de-allocation) right after the
/// @b cc_mqtt5_client_reauth_send() invocation
/// regardless of the returned error code. However, the handle remains valid until
/// the callback is called (in case the @ref CC_Mqtt5ErrorCode_Success was returned).
/// The valid handle can be used to @ref cc_mqtt5_client_reauth_cancel "cancel"
/// the operation before the completion callback is invoked.
///
/// When the "reauth" operation completion callback is invoked the reported
/// "response" information is present <b>if and only if</b> the "status" is
/// @ref CC_Mqtt5AsyncOpStatus_Complete.
///
/// @b NOTE that only single "reauth" operation is allowed at a time, any attempt to
/// prepare a new one via @b cc_mqtt5_client_reauth_prepare() will be rejected
/// until the "reauth" operation completion callback is invoked or
/// the operation is @ref cc_mqtt5_client_reauth_cancel "cancelled".
///
/// @subsection cc_mqtt5_client_reauth_cancel Cancel the "Reauth" Operation.
/// While the handle returned by the @b cc_mqtt5_client_reauth_prepare() is still
/// valid it is possible to cancel / discard the operation.
/// @code
/// ec = cc_mqtt5_client_reauth_cancel(reauth);
/// if (ec != CC_Mqtt5ErrorCode_Success) {
///     printf("ERROR: Failed to cancel reauth with ec=%d\n", ec);
///     ...
/// }
/// @endcode
/// In case the @b cc_mqtt5_client_reauth_send() function was successfully
/// called before the @b cc_mqtt5_client_reauth_cancel(), the operation is
/// cancelled @b without callback invocation.
///
/// In case the re-authentication is rejected by the broker, the latter is
/// expected to send the @b DISCONNECT message resulting in the
/// @ref cc_mqtt5_client_unsolicited_disconnect. In such case the completion
/// callback will be invoked with the @ref CC_Mqtt5AsyncOpStatus_BrokerDisconnected status.
///
/// @section cc_mqtt5_client_unsolicited_disconnect Unsolicited Broker Disconnection
/// The unsolicited broker disconnection can happen in one of the following cases.
///
/// @subsection cc_mqtt5_client_unsolicited_disconnect_msg Receiving DISCONNECT message
/// The broker can initiate disconnection any time by simply sending @b DISCONNECT message.
/// In such case the library responds in the following way:
/// @li Terminates and invokes the callbacks of previously initiated but incomplete operations passing
/// the @ref CC_Mqtt5AsyncOpStatus_BrokerDisconnected as their status report.
/// @li Invokes the @ref cc_mqtt5_client_callbacks_broker_disconnect "disconnection report callback"
///     registered using the @b cc_mqtt5_client_set_broker_disconnect_report_callback() function.
///     The information passed in the @b DISCONNECT message is used to populate reported
///     disconnection information.
///
/// @subsection cc_mqtt5_client_unsolicited_disconnect_protocol_error Detecting Protocol Error
/// In case the broker doesn't fully comply with the MQTT5 specification or there is
/// some unexpected data corruption the library responds in the following way:
/// @li Sends @b DISCONNECT message to the broker reporting error.
/// @li Terminates and invokes the callback of the operation that detected the protocol error with
///     the @ref CC_Mqtt5AsyncOpStatus_ProtocolError status report.
/// @li Terminates and invokes the callbacks of all other previously initiated but incomplete operations passing
///     the @ref CC_Mqtt5AsyncOpStatus_BrokerDisconnected as their status report.
/// @li Invokes the @ref cc_mqtt5_client_callbacks_broker_disconnect "disconnection report callback"
///     registered using the @b cc_mqtt5_client_set_broker_disconnect_report_callback() function
///     without any disconnection information.
///
/// With all said above it means that if application receives @ref CC_Mqtt5AsyncOpStatus_ProtocolError or
/// @ref CC_Mqtt5AsyncOpStatus_BrokerDisconnected status in one of its callback, then
/// the application is expected to wait for the @ref cc_mqtt5_client_callbacks_broker_disconnect "disconnection report callback"
///     which will follow.
///
/// When the @ref cc_mqtt5_client_callbacks_broker_disconnect "disconnection report callback" is called the application is
/// expected to go through the following steps:
/// @li Close network connection.
/// @li Re-establish network connection to the broker.
/// @li Go through the  @ref cc_mqtt5_client_init "re-initialization" process.
/// @li Perform the @ref cc_mqtt5_client_connect "\"connect\"" operation.
///
/// @section cc_mqtt5_client_network_disconnect Network Disconnection
/// The MQTT5 specification also tries to support intermittent network connection by
/// setting the "Session Expiry Interval" property during the @ref cc_mqtt5_client_connect "\"connect\""
/// operation (see @ref CC_Mqtt5ConnectExtraConfig::m_sessionExpiryInterval). Such
/// network disconnection is usually detected by the failing @b read or @b write
/// operations on I/O socket. When the application detects such network disconnection, it
/// is expected to report it to the library using @b cc_mqtt5_client_notify_network_disconnected()
/// function.
/// @code
/// // Report network disconnected
/// cc_mqtt5_client_notify_network_disconnected(client, true);
/// @endcode
/// When network disconnection is reported some internal timers such as waiting for
/// QoS1/QoS2 publish responses get suspended for the period of configured "Session Expiry Interval".
///
/// If the application manages to re-establish connection by repeating failing @b read / @b write
/// operations for several times until they succeed, then the application is expected to report
/// the network re-connection by invoking the same @b cc_mqtt5_client_notify_network_disconnected() function.
/// @code
/// // Report network reconnected
/// cc_mqtt5_client_notify_network_disconnected(client, false);
/// @endcode
/// After such network re-connection is reported, the library will resume its timers and continue
/// functioning as usual (as if network disconnection hasn't happened).
///
/// However, if the network re-connection is not reported until the "Session Expiry Interval" is over,
/// then the library will proceed to the @ref cc_mqtt5_client_unsolicited_disconnect logic.
///
/// @b Note that if the "Session Expiry Interval" was not configured during the
/// @ref cc_mqtt5_client_connect "\"connect\"" operation, invocation of the
/// @b cc_mqtt5_client_notify_network_disconnected() will result in the
/// @ref cc_mqtt5_client_unsolicited_disconnect report right away.
///
/// Inquiry about current network disconnection status can be done using the
/// @b cc_mqtt5_client_is_network_disconnected() function.
/// @code
/// bool disconnected = cc_mqtt5_client_is_network_disconnected(client);
/// @endcode
///
/// Also @b note that invocation of the @b cc_mqtt5_client_init() function (see @ref cc_mqtt5_client_init)
/// will result in library "assuming" network is connected, i.e.
/// invocation of the @b cc_mqtt5_client_is_network_disconnected() will
/// return @b false.
///
/// @section cc_mqtt5_client_thread_safety Thread Safety
/// In general the library is @b NOT thread safe. However, if each thread operates on a separate allocated
/// @ref cc_mqtt5_client_allocation "client", then the locking is required only
/// for the @ref cc_mqtt5_client_allocation "client allocation logic".
///
/// If multiple threads work with the same @ref cc_mqtt5_client_allocation "client"
/// object (such as performing "publish" operations, or handling incoming messages in parallel),
/// then explicit locking logic needs to be implemented by the application itself.
///
/// @section cc_mqtt5_client_debug_build Debug Build
/// The client library uses <a href="https://commschamp.github.io/comms_doc/page_use_prot.html#page_use_prot_error_handling">COMMS_ASSERT()</a>
/// macro to check some internal pre- and post-conditions. It is a bug if the assertion fails, please report if
/// encountered. By default it is like standard 
/// <a href="https://en.cppreference.com/w/cpp/error/assert">assert()</a> but allows overriding 
/// the default failure behavour, which can be more suitable for bare-metal systems. Please
/// refer to the <a href="https://commschamp.github.io/comms_doc/page_assert.html">documentation</a> for details.

