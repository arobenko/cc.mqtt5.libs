#include "UnitTestDefaultBase.h"
#include "UnitTestPropsHandler.h"
#include "UnitTestProtocolDefs.h"

#include <cxxtest/TestSuite.h>

class UnitTestPublish : public CxxTest::TestSuite, public UnitTestDefaultBase
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();
    void test26();
    void test27();
    void test28();
    void test29();
    void test30();
    void test31();
    void test32();
    void test33();
    void test34();
    void test35();
    void test36();
    void test37();
    void test38();
    void test39();
    void test40();
    void test41();
    void test42();
    void test43();
    void test44();
    void test45();
    void test46();
    void test47();
    void test48();

private:
    virtual void setUp() override
    {
        unitTestSetUp();
    }

    virtual void tearDown() override
    {
        unitTestTearDown();
    }
};

void UnitTestPublish::test1()
{
    // Qos0 publish with properties
    // [MQTT-3.3.1-2]
    // [MQTT-3.3.2-4]
    // [MQTT-3.3.2-5]
    // [MQTT-4.3.1-1]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);
    TS_ASSERT_EQUALS(unitTestPublishCount(client), 1U);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    const bool Retain = true;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;
    TS_ASSERT_EQUALS(config.m_topicAliasPref, CC_Mqtt5TopicAliasPreference_UseAliasIfAvailable);
    config.m_retain = Retain;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ContentType("ContentType");
    const std::string ResponseTopic("ResponseTopic");
    const UnitTestData CorrelationData = {0x11, 0x22, 0x33, 0x44};
    const unsigned MsgExpiry = 10;
    const CC_Mqtt5PayloadFormat Format = CC_Mqtt5PayloadFormat_Utf8;

    auto extra = CC_Mqtt5PublishExtraConfig();
    unitTestPublishInitConfigExtra(&extra);
    extra.m_contentType = ContentType.c_str();
    extra.m_responseTopic = ResponseTopic.c_str();
    extra.m_correlationData = &CorrelationData[0];
    extra.m_correlationDataLen = static_cast<decltype(extra.m_correlationDataLen)>(CorrelationData.size());
    extra.m_messageExpiryInterval = MsgExpiry;
    extra.m_format = Format;
    ec = unitTestPublishConfigExtra(publish, &extra);

    const std::string PubUserPropKey1 = "Key1";
    const std::string PubUserPropVal1 = "Val1";    

    auto userProp1 = CC_Mqtt5UserProp();
    userProp1.m_key = PubUserPropKey1.c_str();
    userProp1.m_value = PubUserPropVal1.c_str();
    ec = unitTestPublishAddUserProp(publish, &userProp1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->transportField_flags().field_retain().getBitValue_bit(), Retain);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().isMissing());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    UnitTestPropsHandler propsHandler;
    for (auto& p : publishMsg->field_properties().value()) {
        p.currentFieldExec(propsHandler);
    }

    TS_ASSERT_DIFFERS(propsHandler.m_payloadFormatIndicator, nullptr);
    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5PayloadFormat>(propsHandler.m_payloadFormatIndicator->field_value().value()), Format);      
    TS_ASSERT_DIFFERS(propsHandler.m_messageExpiryInterval, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_messageExpiryInterval->field_value().value(), MsgExpiry);      
    TS_ASSERT_DIFFERS(propsHandler.m_responseTopic, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_responseTopic->field_value().value(), ResponseTopic);     
    TS_ASSERT_DIFFERS(propsHandler.m_correlationData, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_correlationData->field_value().value(), CorrelationData);       
    TS_ASSERT_DIFFERS(propsHandler.m_contentType, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_contentType->field_value().value(), ContentType);       
    TS_ASSERT_EQUALS(propsHandler.m_userProps.size(), 1U);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_first().value(), PubUserPropKey1);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_second().value(), PubUserPropVal1);    

    TS_ASSERT_EQUALS(unitTestPublishCount(client), 0U);
}

void UnitTestPublish::test2()
{
    // Simple Qos1 publish
    // [MQTT-4.3.1-1]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test3()
{
    // Simple Qos1 publish with response properties
    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_requestProblemInfo = true;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    
    const std::string UserPropKey2 = "Key2";
    const std::string UserPropVal2 = "Val2";    

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = NoSubscribers;
    pubackMsg.field_properties().setExists();
    auto& propsVec = pubackMsg.field_properties().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey2;
        field.field_value().field_second().value() = UserPropVal2;
    } while (false);    

    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_reasonCode, static_cast<CC_Mqtt5ReasonCode>(NoSubscribers));
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_reasonStr, ReasonStr);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps.size(), 2U);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[0].m_key, UserPropKey1);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[0].m_value, UserPropVal1);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[1].m_key, UserPropKey2);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[1].m_value, UserPropVal2);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test4()
{
    // Timed out Qos1 publish
    // [MQTT-3.3.1-3]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(!publishMsg1->transportField_flags().field_dup().getBitValue_bit());

    // Timeout
    unitTestTick();
    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);    
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    // Another timeout
    unitTestTick();
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test5()
{
    // Simple Qos2 publish
    // [MQTT-4.3.3-2]
    // [MQTT-4.3.3-4]
    auto* client = unitTestAllocClient(true);
    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_requestProblemInfo = true;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubrecMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    
    const std::string UserPropKey2 = "Key2";
    const std::string UserPropVal2 = "Val2";        

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = NoSubscribers;
    pubrecMsg.field_properties().setExists();
    auto& propsVec = pubrecMsg.field_properties().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey2;
        field.field_value().field_second().value() = UserPropVal2;
    } while (false);    

    unitTestReceiveMessage(pubrecMsg);
    TS_ASSERT(!unitTestIsPublishComplete());

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    pubcompMsg.field_reasonCode().setExists();
    pubcompMsg.field_reasonCode().field().value() = NoSubscribers;
    pubcompMsg.field_properties().setExists();
    auto& compPropsVec = pubcompMsg.field_properties().field().value();
    do {
        compPropsVec.resize(compPropsVec.size() + 1U);
        auto& field = compPropsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    do {
        compPropsVec.resize(compPropsVec.size() + 1U);
        auto& field = compPropsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    do {
        compPropsVec.resize(compPropsVec.size() + 1U);
        auto& field = compPropsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey2;
        field.field_value().field_second().value() = UserPropVal2;
    } while (false);       
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_NoMatchingSubscribers);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_reasonStr, ReasonStr);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps.size(), 2U);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[0].m_key, UserPropKey1);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[0].m_value, UserPropVal1);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[1].m_key, UserPropKey2);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_userProps[1].m_value, UserPropVal2);

    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test6()
{
    // Timed out Qos2 publish
    // [MQTT-3.3.1-3]
    // [MQTT-4.3.3-5]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(!publishMsg1->transportField_flags().field_dup().getBitValue_bit());

    // Timeout
    unitTestTick();
    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);    
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg2->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);
    TS_ASSERT(!unitTestIsPublishComplete());

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT(!unitTestIsPublishComplete());

    // Timeout
    unitTestTick();
    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);   
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value()); 
    
    // Another timeout
    unitTestTick();
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();   
}

void UnitTestPublish::test7()
{
    // Qos0 publish with topic id
    // [MQTT-3.3.2-8]
    auto* client = unitTestAllocClient();
    unitTestPerformPubTopicAliasConnect(client, __FUNCTION__, 10);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    auto ec = unitTestPubTopicAliasAlloc(client, Topic.c_str(), 2U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();
    } while (false);
    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);
        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }

        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);

    // Sending third time
    do {
        unitTestTick(1000);
        auto publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);
        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }

        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);    
}

void UnitTestPublish::test8()
{
    // Qos1 publish with topic id
    // [MQTT-3.3.2-8]
    auto* client = unitTestAllocClient();
    unitTestPerformPubTopicAliasConnect(client, __FUNCTION__, 10);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    auto ec = unitTestPubTopicAliasAlloc(client, Topic.c_str(), 3U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();

        UnitTestPubackMsg pubackMsg;
        pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubackMsg);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();        
    } while (false);

    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto* publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());

        UnitTestPubackMsg pubackMsg;
        pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubackMsg);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();      
    } while (false);    
}

void UnitTestPublish::test9()
{
    // Qos2 publish with topic id
    // [MQTT-3.3.2-8]
    auto* client = unitTestAllocClient();
    unitTestPerformPubTopicAliasConnect(client, __FUNCTION__, 10);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    auto ec = unitTestPubTopicAliasAlloc(client, Topic.c_str(), 3U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();

        unitTestTick(1000);
        UnitTestPubrecMsg pubrecMsg;
        pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubrecMsg);

        sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
        auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
        TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());        

        unitTestTick(1000);
        UnitTestPubcompMsg pubcompMsg;
        pubcompMsg.field_packetId().value() = pubrelMsg->field_packetId().value();
        unitTestReceiveMessage(pubcompMsg);

        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();        
    } while (false);

    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto* publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());

        unitTestTick(1000);
        UnitTestPubrecMsg pubrecMsg;
        pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubrecMsg);

        sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
        auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
        TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());        

        unitTestTick(1000);
        UnitTestPubcompMsg pubcompMsg;
        pubcompMsg.field_packetId().value() = pubrelMsg->field_packetId().value();
        unitTestReceiveMessage(pubcompMsg);

        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();     
    } while (false);    
}

void UnitTestPublish::test10()
{
    // Invalid publish topics
    // [MQTT-3.3.2-2]
    // [MQTT-4.7.2-1]
    // [MQTT-4.7.3-1]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = "hello/+/bla";
    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_topic = "hello/#";
    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    config.m_topic = "$hello";
    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    config.m_topic = "";
    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);     

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_InsufficientConfig);   
}

void UnitTestPublish::test11()
{
    // Testing invalid packet ID in PUBACK
    // [MQTT-2.2.1-5]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    // Unexpected packet ID in puback
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(publishMsg->field_packetId().field().value() + 1U);
    unitTestReceiveMessage(pubackMsg);
    
    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestTick(); // timeout, send second time
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    // Unexpected packet ID in pubrec
    unitTestTick(1000);
    unitTestReceiveMessage(pubackMsg);

    unitTestTick(); // timeout
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test12()
{
    // Testing invalid packet ID in PUBREC
    // [MQTT-2.2.1-5]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    // Unexpected packet ID in pubrec
    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(publishMsg->field_packetId().field().value() + 1U);
    unitTestReceiveMessage(pubrecMsg);
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(); // timeout, send second time
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    // Unexpected packet ID in pubrec
    unitTestTick(1000);
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg2 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg2, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg2->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(); // timeout
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}


void UnitTestPublish::test13()
{
    // Testing invalid packet ID in PUBCOMP
    // [MQTT-2.2.1-5]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(publishMsg->field_packetId().field().value());
    unitTestReceiveMessage(pubrecMsg);
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    // Unexpected packet ID in PUBCOMP
    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().setValue(pubrecMsg.field_packetId().value() + 1U);
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestHasSentMessage());

    unitTestTick(); // Retry timeout
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg2 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg2, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg2->field_packetId().value(), pubrecMsg.field_packetId().value());

    // Same unexpected packet ID in PUBCOMP
    unitTestTick(1000);
    unitTestReceiveMessage(pubcompMsg);
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestHasSentMessage());

    unitTestTick(); // timeout
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test14()
{
    // Suspending Qos1 publish operation when network is disconnected
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocClient(true);

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);
    TS_ASSERT(unitTestIsConnected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const unsigned ResponseTimeout = 2000;
    auto ec = unitTestPublishSetResponseTimeout(publish, ResponseTimeout);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout);

    unitTestTick(1000);
    unitTestNotifyNetworkDisconnected(client);
    TS_ASSERT(!unitTestIsDisconnected());

    TS_ASSERT(!unitTestIsPublishComplete());
    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(); // Session expiry
    TS_ASSERT(unitTestIsPublishComplete()); // Stored until reconnect
    auto& responseInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(responseInfo.m_status, CC_Mqtt5AsyncOpStatus_BrokerDisconnected);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test15()
{
    // Suspending Qos2 publish operation when network is disconnected
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocClient();

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);
    TS_ASSERT(unitTestIsConnected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const unsigned ResponseTimeout = 2000;
    auto ec = unitTestPublishSetResponseTimeout(publish, ResponseTimeout);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout);

    unitTestTick(1000);
    unitTestNotifyNetworkDisconnected(client);

    TS_ASSERT(!unitTestIsPublishComplete());
    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(); // Session expiry
    TS_ASSERT(unitTestIsPublishComplete()); // Stored in session
    auto& responseInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(responseInfo.m_status, CC_Mqtt5AsyncOpStatus_BrokerDisconnected);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test16()
{
    // Testing rejection of "Reason String" in PUBACK
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = NoSubscribers;
    pubackMsg.field_properties().setExists();
    auto& propsVec = pubackMsg.field_properties().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test17()
{
    // Testing rejection of "User Properties" in PUBACK
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = NoSubscribers;
    pubackMsg.field_properties().setExists();
    auto& propsVec = pubackMsg.field_properties().field().value();

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());    
}

void UnitTestPublish::test18()
{
    // Testing rejection of "Reason String" in PUBREC
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = NoSubscribers;
    pubrecMsg.field_properties().setExists();
    auto& propsVec = pubrecMsg.field_properties().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test19()
{
    // Testing rejection of "User Properties" in PUBREL
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = NoSubscribers;
    pubrecMsg.field_properties().setExists();
    auto& propsVec = pubrecMsg.field_properties().field().value();

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());    
}

void UnitTestPublish::test20()
{
    // Testing rejection of "Reason String" in PUBCOMP
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");    

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    pubcompMsg.field_reasonCode().setExists();
    pubcompMsg.field_reasonCode().field().value() = NoSubscribers;
    pubcompMsg.field_properties().setExists();
    auto& propsVec = pubcompMsg.field_properties().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test21()
{
    // Testing rejection of "User Properties" in PUBCOMP
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    pubcompMsg.field_reasonCode().setExists();
    pubcompMsg.field_reasonCode().field().value() = NoSubscribers;
    pubcompMsg.field_properties().setExists();
    auto& propsVec = pubcompMsg.field_properties().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test22()
{
    // Testing rejection of publish with QoS higher than allowed by broker
    // [MQTT-3.2.2-11]
    // [MQTT-4.9.0-2]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_maxQos = CC_Mqtt5QoS_AtMostOnceDelivery;
    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);

    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestIsPublishComplete());
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test23()
{
    // Testing rejection of publish with retain when it's unavailable
    // [MQTT-3.2.2-14]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    bool retainAvailable = false;
    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_retainAvailable = &retainAvailable;
    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);

    TS_ASSERT(unitTestIsConnected(client));

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    config.m_retain = true;

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_retain = false;
    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestIsPublishComplete());
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test24()
{
    // Testing rejection of publish exceeding max packet size
    // [MQTT-3.2.2-15]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    const unsigned MaxPacketSize = 300;
    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_maxPacketSize = MaxPacketSize;
    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);

    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data(MaxPacketSize, 0x1);

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
    TS_ASSERT_EQUALS(publish, nullptr);

    publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size() - 100U);
    ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    TS_ASSERT(unitTestIsPublishComplete());
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test25()
{
    // Testing rejection of invalid QoS value
    // [MQTT-3.3.1-4]
    
    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);

    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = static_cast<decltype(config.m_qos)>(3);

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    
}

void UnitTestPublish::test26()
{
    // Qos0 publish with topic alias with network disconnection
    // [MQTT-3.3.2-7]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_topicAliasMax = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    auto ec = unitTestPubTopicAliasAlloc(client, Topic.c_str(), 1U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();
    } while (false);
    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);
        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }

        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);   
    
    unitTestTick(1000);
    unitTestNotifyNetworkDisconnected(client);

    // Reconnecting
    basicConfig.m_cleanStart = false;
    responseConfig.m_sessionPresent = true;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));

    TS_ASSERT_EQUALS(unitTestPubTopicAliasCount(client), 0);

    ec = unitTestPubTopicAliasAlloc(client, Topic.c_str(), 1U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
     
    do {
        auto* publish = unitTestPublishPrepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = unitTestPublishConfigBasic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_properties().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);     
}

void UnitTestPublish::test27()
{
    // Testing inability to use wildcards in "Response Topic"
    // [MQTT-3.3.2-14]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    auto extra = CC_Mqtt5PublishExtraConfig();
    unitTestPublishInitConfigExtra(&extra);
    extra.m_responseTopic = "#";

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigExtra(publish, &extra);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    extra.m_responseTopic = "hello/+";
    ec = unitTestPublishConfigExtra(publish, &extra);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    extra.m_responseTopic = "bla";
    ec = unitTestPublishConfigExtra(publish, &extra);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
}

void UnitTestPublish::test28()
{
    // Testing incoming PUBREC instead of PUBACK
    // [MQTT-3.3.4-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId);
   
    unitTestReceiveMessage(pubrecMsg);   
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestPublish::test29()
{
    // Testing incoming PUBACK instead of PUBREC
    // [MQTT-3.3.4-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId);
   
    unitTestReceiveMessage(pubackMsg);   
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestPublish::test30()
{
    // Testing limit of the outgoing high Qos publishes
    // [MQTT-3.3.4-7]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_recvMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestIsPublishComplete());

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    // QoS0 message is sent right away even when exceeding the "Receive Maximum" set by broker
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(publishMsg->field_packetId().isMissing()); // QoS0 sent

    TS_ASSERT(unitTestIsPublishComplete());
    auto* pubInfo = &unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo->m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     

    auto* publish3 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish3, nullptr);

    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;
    ec = unitTestPublishConfigBasic(publish3, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish3);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);


    TS_ASSERT(!unitTestHasSentMessage()); // the sent message sending is delayed

    // Resend the QoS0 message 
    auto* publish4 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish4, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = unitTestPublishConfigBasic(publish4, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish4);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    // QoS0 is sent right away
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(publishMsg->field_packetId().isMissing()); // QoS0 sent

    TS_ASSERT(unitTestIsPublishComplete());
    pubInfo = &unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo->m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    pubInfo = &unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo->m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    // QoS2 is sent right away
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(publishMsg->field_packetId().doesExist()); 
    auto packetId2 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestIsPublishComplete()); // QoS2 is not complete yet  

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);    
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), packetId2);
    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubcompMsg);
    TS_ASSERT(unitTestIsPublishComplete());
    pubInfo = &unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo->m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

}

void UnitTestPublish::test31()
{
    // Testing rejection of the Qos1 publish by the broker
    // [MQTT-4.4.0-2]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId);
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::UnspecifiedError;
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_UnspecifiedError);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test32()
{
    // Testing rejection of the Qos2 publish by the broker
    // [MQTT-4.4.0-2]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = unitTestPublishConfigBasic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId);
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::UnspecifiedError;
    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(pubrespInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_UnspecifiedError);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test33()
{
    // Testing re-publish of not acked Qos1 messages in the same order.
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic1("some/topic1");
    const std::string Topic2("some/topic2");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    // Not delay between publishes.
    config.m_topic = Topic2.c_str();

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    auto packetId2 = publishMsg2->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId1, packetId2);

    unitTestTick(); // Timeout
    TS_ASSERT(!unitTestIsPublishComplete());

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);


    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg2->field_packetId().field().value(), packetId2);

    TS_ASSERT(!unitTestIsPublishComplete());
}

void UnitTestPublish::test34()
{
    // Testing re-publish of not acked Qos1 and Qos2 messages in the same order.
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic1("some/topic1");
    const std::string Topic2("some/topic2");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    TS_ASSERT(unitTestHasSentMessage());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(publishMsg1->field_packetId().doesExist());
    auto packetId1 = publishMsg1->field_packetId().field().value();

    // Not delay between publishes.
    config.m_topic = Topic2.c_str();
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    auto packetId2 = publishMsg2->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId1, packetId2);

    unitTestTick(); // Timeout
    TS_ASSERT(!unitTestIsPublishComplete());

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(publishMsg1->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg1->field_packetId().field().value(), packetId1);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg2->field_packetId().field().value(), packetId2);

    TS_ASSERT(!unitTestIsPublishComplete());
}

void UnitTestPublish::test35()
{
    // Testing preserving of the PUBLISH (QoS1) operation after the broker disconnection.
    // [MQTT-4.4.0-1]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic1("some/topic1");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    unitTestTick(1000);
    unitTestNotifyNetworkDisconnected(client);
    TS_ASSERT(!unitTestIsDisconnected());
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks());

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, extraConfig.m_sessionExpiryInterval * 1000U);

    unitTestClearState();

    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH is present
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);  
    TS_ASSERT(publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test36()
{
    // Testing preserving of the PUBLISH (QoS2) operation after the broker disconnection.
    // [MQTT-4.4.0-1]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client)); 

    const std::string Topic1("some/topic1");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    unitTestTick(100);
    unitTestNotifyNetworkDisconnected(client);
    TS_ASSERT(!unitTestIsDisconnected());
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks());

    unitTestClearState();

    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH is present
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);  
    TS_ASSERT(publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test37()
{
    // Testing preserving of the PUBLISH (QoS2) operation after the broker disconnection and after reception of PUBREC.
    // [MQTT-4.4.0-1]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client)); 

    const std::string Topic1("some/topic1");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());    

    unitTestTick(1000);
    unitTestNotifyNetworkDisconnected(client);
    TS_ASSERT(!unitTestIsDisconnected());
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks());

    unitTestClearState();

    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH op is still present
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);  
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), packetId1);

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test38()
{
    // Testing preserving of the PUBLISH (QoS1) operation after the broker disconnection and termination upon reconnect
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client)); 

    const std::string Topic1("some/topic1");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    

    unitTestTick(1000);
    unitTestNotifyNetworkDisconnected(client);
    TS_ASSERT(!unitTestIsDisconnected());
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks());

    unitTestClearState();

    // Reconnection with attempt to restore the session, but the clean session is reported
    unitTestPerformBasicConnect(client, __FUNCTION__, true);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_Aborted);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test39()
{
    // Testing preserving of the PUBLISH (QoS1) operation after the broker disconnection (initiated by the broker).
    // [MQTT-4.4.0-1]

    auto* client = unitTestAllocClient();

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);
    TS_ASSERT(unitTestIsConnected(client));

    const std::string Topic1("some/topic1");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    unitTestTick(100);
    UnitTestDisconnectMsg disconnectMsg;
    unitTestReceiveMessage(disconnectMsg);

    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(unitTestHasDisconnectInfo());
    auto& disconnectInfo = unitTestDisconnectInfo();
    TS_ASSERT_EQUALS(disconnectInfo.m_reasonCode, CC_Mqtt5ReasonCode_NormalDisconnection);
    unitTestPopDisconnectInfo();    
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks()); // Has session expiry timeout

    unitTestClearState();
    
    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH is present
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);  
    TS_ASSERT(publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test40()
{
    // Testing limit of the outgoing high Qos publishes when paused publishes get cancelled

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_recvMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestIsPublishComplete());

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(!unitTestHasSentMessage()); // the sent message sending is delayed

    auto* publish3 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish3, nullptr);

    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;
    ec = unitTestPublishConfigBasic(publish3, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish3, false);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(!unitTestHasSentMessage()); // the sent message sending is delayed

    TS_ASSERT_DIFFERS(publish3, nullptr);
    ec = unitTestPublishCancel(publish3);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete()); // No callback is invoked

    TS_ASSERT(!unitTestHasSentMessage()); // No new message has been sent

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(publishMsg->field_packetId().doesExist()); // QoS1 sent
    auto packetId2 = publishMsg->field_packetId().field().value();

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg2;
    pubackMsg2.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubackMsg2);    

    TS_ASSERT(unitTestIsPublishComplete());
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    TS_ASSERT(!unitTestHasSentMessage()); 
}

void UnitTestPublish::test41()
{
    // Testing limit of the outgoing high Qos publishes with broker disconnect

    auto* client = unitTestAllocClient(true);
    TS_ASSERT_EQUALS(unitTestPublishGetOrdering(client), CC_Mqtt5PublishOrdering_SameQos);
    auto ec = unitTestPublishSetOrdering(client, CC_Mqtt5PublishOrdering_Full);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_recvMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestIsPublishComplete());

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;
    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto* publish3 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish3, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = unitTestPublishConfigBasic(publish3, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish3);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(!unitTestHasSentMessage()); // the sent message sending is delayed

    unitTestTick(100);
    UnitTestDisconnectMsg disconnectMsg;
    unitTestReceiveMessage(disconnectMsg);

    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(unitTestHasDisconnectInfo());
    auto& disconnectInfo = unitTestDisconnectInfo();
    TS_ASSERT_EQUALS(disconnectInfo.m_reasonCode, CC_Mqtt5ReasonCode_NormalDisconnection);
    unitTestPopDisconnectInfo();    

    TS_ASSERT(!unitTestCheckNoTicks()); // has session expiry timer 
    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, extraConfig.m_sessionExpiryInterval * 1000U);

    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestClearState();

    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    connectRespConfig.m_recvMaximum = 1;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH is re-sent
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);  
    TS_ASSERT(publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);    

    TS_ASSERT(!unitTestHasSentMessage()); // the other messages sending is delayed

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    // QoS2 is sent right away
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit()); // NO DUP
    TS_ASSERT(publishMsg->field_packetId().doesExist()); 
    auto packetId2 = publishMsg->field_packetId().field().value();

    // OoS0 is NOT sent right away
    TS_ASSERT(!unitTestHasSentMessage()); 
    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);    
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), packetId2);
    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubcompMsg);
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo2 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo2.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();   

    // QoS0 is sent after QoS2 is complete
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().isMissing()); // QoS0 sent

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo3 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo3.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();       
}

void UnitTestPublish::test42()
{
    // Testing limit of the outgoing high Qos publishes with broker disconnect, broker removes the limit

    auto* client = unitTestAllocClient(true);
    TS_ASSERT_EQUALS(unitTestPublishGetOrdering(client), CC_Mqtt5PublishOrdering_SameQos);
    auto ec = unitTestPublishSetOrdering(client, CC_Mqtt5PublishOrdering_Full);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);     

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;    

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_recvMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestIsPublishComplete());

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;
    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto* publish3 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish3, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = unitTestPublishConfigBasic(publish3, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish3);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(!unitTestHasSentMessage()); // the sent message sending is delayed    

    unitTestTick(100);
    UnitTestDisconnectMsg disconnectMsg;
    unitTestReceiveMessage(disconnectMsg);

    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(unitTestHasDisconnectInfo());
    auto& disconnectInfo = unitTestDisconnectInfo();
    TS_ASSERT_EQUALS(disconnectInfo.m_reasonCode, CC_Mqtt5ReasonCode_NormalDisconnection);
    unitTestPopDisconnectInfo();    

    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks()); // Has session expiry calculation

    unitTestClearState();

    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH is re-sent
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);  
    TS_ASSERT(publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);    

    // Checking other PUBLISH-es are resumed

    // QoS2 is also sent right away
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit()); // NO DUP
    TS_ASSERT(publishMsg->field_packetId().doesExist()); 
    auto packetId2 = publishMsg->field_packetId().field().value();

    // QoS0 is not sent right away
    TS_ASSERT(!unitTestHasSentMessage()); 

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);    
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), packetId2);
    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo2 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo2.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();  

    // QoS0 is sent
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().isMissing()); // QoS0 sent

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo3 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo3.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();         
}

void UnitTestPublish::test43()
{
    // Testing limit of the outgoing high Qos publishes with broker disconnect, broker increases the limit

    auto* client = unitTestAllocClient(true);

    TS_ASSERT_EQUALS(unitTestPublishGetOrdering(client), CC_Mqtt5PublishOrdering_SameQos);
    auto ec = unitTestPublishSetOrdering(client, CC_Mqtt5PublishOrdering_Full);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);      

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;       

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_recvMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestIsPublishComplete());

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;
    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestPublishWasInitiated(publish2));

    auto* publish3 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish3, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = unitTestPublishConfigBasic(publish3, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish3);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(!unitTestHasSentMessage()); // the sent message sending is delayed
    TS_ASSERT(!unitTestPublishWasInitiated(publish3));

    auto* publish4 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish4, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    ec = unitTestPublishConfigBasic(publish4, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish4);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(!unitTestHasSentMessage()); // the sent message sending is delayed
    TS_ASSERT(!unitTestPublishWasInitiated(publish4));    

    unitTestTick(100);
    UnitTestDisconnectMsg disconnectMsg;
    unitTestReceiveMessage(disconnectMsg);

    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(unitTestHasDisconnectInfo());
    auto& disconnectInfo = unitTestDisconnectInfo();
    TS_ASSERT_EQUALS(disconnectInfo.m_reasonCode, CC_Mqtt5ReasonCode_NormalDisconnection);
    unitTestPopDisconnectInfo();    

    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks()); // has session expiry
    
    unitTestClearState();

    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    connectRespConfig.m_recvMaximum = 2;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH is re-sent
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);  
    TS_ASSERT(publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);    

    // Checking other PUBLISH-es are resumed

    // QoS2 is  sent right away
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit()); // NO DUP
    TS_ASSERT_EQUALS(static_cast<CC_Mqtt5QoS>(publishMsg->transportField_flags().field_qos().value()), CC_Mqtt5QoS_ExactlyOnceDelivery); 
    TS_ASSERT(publishMsg->field_packetId().doesExist()); 
    auto packetId2 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestHasSentMessage()); // QoS0 is not sent right away

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);    
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), packetId2);
    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo2 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo2.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     

    // QoS0 is also sent
    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().isMissing()); // QoS0 sent

    // QoS0 completion
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo3 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo3.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    // Last QoS1 message is sent
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);  
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId4 = publishMsg->field_packetId().field().value();
    TS_ASSERT(!unitTestIsPublishComplete());  

    UnitTestPubackMsg pubrecMsg4;
    pubrecMsg4.field_packetId().setValue(packetId4);
    unitTestReceiveMessage(pubrecMsg4);    

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo4 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo4.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     

}

void UnitTestPublish::test44()
{
    // Testing out of order publishes of the QoS0 messages

    auto* client = unitTestAllocClient(true);

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_recvMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    TS_ASSERT(!unitTestIsPublishComplete());

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestPublishWasInitiated(publish2));
    TS_ASSERT(!unitTestHasSentMessage());

    auto* publish3 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish3, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = unitTestPublishConfigBasic(publish3, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish3);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg3 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg3, nullptr);    
    TS_ASSERT(publishMsg3->field_packetId().isMissing());
    
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo3 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo3.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     

    auto* publish4 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish4, nullptr);

    ec = unitTestPublishConfigBasic(publish4, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish4);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestHasSentMessage()); 
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg4 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg4, nullptr);
    TS_ASSERT(publishMsg4->field_packetId().isMissing());

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo4 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo4.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg1;
    pubackMsg1.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg1);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo(); 

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);  
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    auto packetId2 = publishMsg2->field_packetId().field().value();

    TS_ASSERT(!unitTestHasSentMessage()); // Qos0 is not sent right away

    UnitTestPubackMsg pubackMsg2;
    pubackMsg2.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubackMsg2);  

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo2 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo2.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     
}

void UnitTestPublish::test45()
{
    // Testing resend in the resumed session when topic alias was in use before disconnection.

    auto* client = unitTestAllocClient(true);

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;   

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_topicAliasMax = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig, nullptr, &responseConfig);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto ec = unitTestPubTopicAliasAlloc(client, Topic.c_str(), 1U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(publishMsg1->field_packetId().isMissing());
    TS_ASSERT_EQUALS(publishMsg1->field_topic().value(), Topic);
    
    UnitTestPropsHandler propsHandler1;
    for (auto& p : publishMsg1->field_properties().value()) {
        p.currentFieldExec(propsHandler1);
    }    

    TS_ASSERT_DIFFERS(propsHandler1.m_topicAlias, nullptr);
    auto alias1 = propsHandler1.m_topicAlias->field_value().value();    

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();     

    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2, false);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(unitTestPublishWasInitiated(publish2));
    TS_ASSERT(unitTestHasSentMessage());

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_topic().value().empty()); // Topic alias is in use
    TS_ASSERT(publishMsg2->field_packetId().doesExist());    
    auto packetId2 = publishMsg2->field_packetId().field().value();

    UnitTestPropsHandler propsHandler2;
    for (auto& p : publishMsg2->field_properties().value()) {
        p.currentFieldExec(propsHandler2);
    }    

    TS_ASSERT_DIFFERS(propsHandler2.m_topicAlias, nullptr);
    auto alias2 = propsHandler2.m_topicAlias->field_value().value();    
    TS_ASSERT_EQUALS(alias1, alias2);

    unitTestTick(100);
    UnitTestDisconnectMsg disconnectMsg;
    unitTestReceiveMessage(disconnectMsg);
    
    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(unitTestHasDisconnectInfo());
    auto& disconnectInfo = unitTestDisconnectInfo();
    TS_ASSERT_EQUALS(disconnectInfo.m_reasonCode, CC_Mqtt5ReasonCode_NormalDisconnection);
    unitTestPopDisconnectInfo();    
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestCheckNoTicks()); // Has session expiry timeout

    unitTestClearState();
    
    // Reconnection with attempt to restore the session
    auto connectConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&connectConfig);

    connectConfig.m_clientId = __FUNCTION__;
    connectConfig.m_cleanStart = false;

    auto connectRespConfig = UnitTestConnectResponseConfig();
    connectRespConfig.m_sessionPresent = true;
    connectRespConfig.m_topicAliasMax = 10;
    unitTestPerformConnect(client, &connectConfig, nullptr, nullptr, nullptr, &connectRespConfig);

    // Checking the PUBLISH is present
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto publishMsg3 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg3, nullptr);  
    TS_ASSERT(publishMsg3->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg3->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg3->field_packetId().field().value(), packetId2);        
    TS_ASSERT(!publishMsg3->field_topic().value().empty());

    UnitTestPropsHandler propsHandler3;
    for (auto& p : publishMsg3->field_properties().value()) {
        p.currentFieldExec(propsHandler3);
    }    

    // The topic alias should not be used in resend
    TS_ASSERT_EQUALS(propsHandler3.m_topicAlias, nullptr);
}

void UnitTestPublish::test46()
{
    // Testing out-of-order PUBACK
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient(true);

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestHasSentMessage());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(publishMsg1->field_packetId().doesExist());
    auto packetId1 = publishMsg1->field_packetId().field().value();
    
    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2, false);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(unitTestPublishWasInitiated(publish2));

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());    
    auto packetId2 = publishMsg2->field_packetId().field().value();

    // Out of order PUBACK
    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg2;
    pubackMsg2.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubackMsg2);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg3 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg3, nullptr);
    TS_ASSERT(publishMsg3->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg3->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg3->field_packetId().field().value(), packetId1);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg4 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg4, nullptr);
    TS_ASSERT(publishMsg4->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg4->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg4->field_packetId().field().value(), packetId2);  

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg1;
    pubackMsg1.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg1);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();

    unitTestReceiveMessage(pubackMsg2);
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo2 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo2.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test47()
{
    // Testing out-of-order PUBREC
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient(true);

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestHasSentMessage());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(publishMsg1->field_packetId().doesExist());
    auto packetId1 = publishMsg1->field_packetId().field().value();
    
    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;
    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2, false);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(unitTestPublishWasInitiated(publish2));

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());    
    auto packetId2 = publishMsg2->field_packetId().field().value();

    // Out of order PUBREC
    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg2;
    pubrecMsg2.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubrecMsg2);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg3 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg3, nullptr);
    TS_ASSERT(publishMsg3->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg3->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg3->field_packetId().field().value(), packetId1);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg4 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg4, nullptr);
    TS_ASSERT(publishMsg4->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT(publishMsg4->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg4->field_packetId().field().value(), packetId2);  

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg1;
    pubackMsg1.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubackMsg1);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();

    unitTestReceiveMessage(pubrecMsg2);
    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg4 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg4, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg4->field_packetId().value(), packetId2);  

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg3;
    pubcompMsg3.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubcompMsg3);   

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo2 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo2.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();         
}

void UnitTestPublish::test48()
{
    // Testing out-of-order PUBCOMP
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient(true);

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    unitTestPublishInitConfigBasic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish1 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = unitTestPublishConfigBasic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestHasSentMessage());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(publishMsg1->field_packetId().doesExist());
    auto packetId1 = publishMsg1->field_packetId().field().value();
    
    auto* publish2 = unitTestPublishPrepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    ec = unitTestPublishConfigBasic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 

    ec = unitTestSendPublish(publish2, false);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(unitTestPublishWasInitiated(publish2));

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());    
    auto packetId2 = publishMsg2->field_packetId().field().value();

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg1;
    pubrecMsg1.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubrecMsg1);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg1 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg1, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg1->field_packetId().value(), packetId1);      

    UnitTestPubrecMsg pubrecMsg2;
    pubrecMsg2.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubrecMsg2);    

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg2 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg2, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg2->field_packetId().value(), packetId2);        

    // Out-of-order PUBCOMPS
    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg2;
    pubcompMsg2.field_packetId().setValue(packetId2);
    unitTestReceiveMessage(pubcompMsg2);    

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg3 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg3, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg3->field_packetId().value(), packetId1);

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg4 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg4, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg4->field_packetId().value(), packetId2);

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg1;
    pubcompMsg1.field_packetId().setValue(packetId1);
    unitTestReceiveMessage(pubcompMsg1); 

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo1 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo1.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();

    unitTestReceiveMessage(pubcompMsg2);
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubrespInfo2 = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubrespInfo2.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();         
}