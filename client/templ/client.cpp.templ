//
// Copyright 2023 - 2024 (C). Alex Robenko. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "##NAME##client.h"
#include "ClientCreator.h"

namespace
{

cc_mqtt5_client::ClientCreator& getClientCreator()
{
    static cc_mqtt5_client::ClientCreator Creator;
    return Creator;
}

inline cc_mqtt5_client::Client* clientFromHandle(CC_Mqtt5ClientHandle client)
{
    return reinterpret_cast<cc_mqtt5_client::Client*>(client.m_ptr);
}

} // namespace

CC_Mqtt5ClientHandle cc_mqtt5_##NAME##client_new()
{
    auto client = getClientCreator().alloc();
    CC_Mqtt5ClientHandle result;
    result.m_ptr = client.release();
    return result;    
}

void cc_mqtt5_##NAME##client_free(CC_Mqtt5ClientHandle client)
{
    getClientCreator().free(clientFromHandle(client));
}

CC_Mqtt5ErrorCode cc_mqtt4_##NAME##client_init(CC_Mqtt5ClientHandle client)
{
    return clientFromHandle(client)->init();
}

void cc_mqtt5_##NAME##client_set_next_tick_program_callback(
    CC_Mqtt5ClientHandle client,
    CC_Mqtt5NextTickProgramFn fn,
    void* data)
{
    clientFromHandle(client)->setNextTickProgramCallback(fn, data);
}

void cc_mqtt5_##NAME##client_set_cancel_next_tick_wait_callback(
    CC_Mqtt5ClientHandle client,
    CC_Mqtt5CancelNextTickWaitFn fn,
    void* data)
{
    clientFromHandle(client)->setCancelNextTickWaitCallback(fn, data);
}

void cc_mqtt5_##NAME##client_set_send_output_data_callback(
    CC_Mqtt5ClientHandle client,
    CC_Mqtt5SendOutputDataFn fn,
    void* data)
{
    clientFromHandle(client)->setSendOutputDataCallback(fn, data);
}

