//
// Copyright 2023 - 2024 (C). Alex Robenko. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "##NAME##client.h"
#include "ClientAllocator.h"
#include "ConnectOp.h"

namespace
{

cc_mqtt5_client::ClientAllocator& getClientAllocator()
{
    static cc_mqtt5_client::ClientAllocator Allocator;
    return Allocator;
}

inline cc_mqtt5_client::Client* clientFromHandle(CC_Mqtt5ClientHandle client)
{
    return reinterpret_cast<cc_mqtt5_client::Client*>(client.m_ptr);
}

inline cc_mqtt5_client::ConnectOp* connectOpFromHandle(CC_Mqtt5ConnectHandle connectOp)
{
    return reinterpret_cast<cc_mqtt5_client::ConnectOp*>(connectOp.m_ptr);
}

} // namespace

CC_Mqtt5ClientHandle cc_mqtt5_##NAME##client_new()
{
    auto client = getClientAllocator().alloc();
    auto result = CC_Mqtt5ClientHandle();
    result.m_ptr = client.release();
    return result;    
}

bool cc_mqtt5_##NAME##client_handle_is_valid(CC_Mqtt5ClientHandle client)
{
    return client.m_ptr != nullptr;
}

void cc_mqtt5_##NAME##client_free(CC_Mqtt5ClientHandle client)
{
    getClientAllocator().free(clientFromHandle(client));
}

CC_Mqtt5ErrorCode cc_mqtt4_##NAME##client_init(CC_Mqtt5ClientHandle client)
{
    return clientFromHandle(client)->init();
}

void cc_mqtt5_##NAME##client_tick(CC_Mqtt5ClientHandle client, unsigned ms)
{
    clientFromHandle(client)->tick(ms);
}

unsigned cc_mqtt5_##NAME##client_process_data(CC_Mqtt5ClientHandle client, const unsigned char* buf, unsigned bufLen)
{
    return clientFromHandle(client)->processData(buf, bufLen);
}

CC_Mqtt5ConnectHandle cc_mqtt5_##NAME##client_connect_prepare(CC_Mqtt5ClientHandle client, CC_Mqtt5ErrorCode* ec)
{
    return clientFromHandle(client)->connectPrepare(ec);
}

bool cc_mqtt5_##NAME##client_connect_handle_is_valid(CC_Mqtt5ConnectHandle connect)
{
    return connect.m_ptr != nullptr;
}

CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_apply(CC_Mqtt5ConnectHandle connect)
{
    if (!cc_mqtt5_##NAME##client_connect_handle_is_valid(connect)) {
        return CC_Mqtt5ErrorCode_BadParam;
    }

    return connectOpFromHandle(connect)->apply();
}

// --------------------- Callbacks ---------------------

void cc_mqtt5_##NAME##client_set_next_tick_program_callback(
    CC_Mqtt5ClientHandle client,
    CC_Mqtt5NextTickProgramCb cb,
    void* data)
{
    clientFromHandle(client)->setNextTickProgramCallback(cb, data);
}

void cc_mqtt5_##NAME##client_set_cancel_next_tick_wait_callback(
    CC_Mqtt5ClientHandle client,
    CC_Mqtt5CancelNextTickWaitCb cb,
    void* data)
{
    clientFromHandle(client)->setCancelNextTickWaitCallback(cb, data);
}

void cc_mqtt5_##NAME##client_set_send_output_data_callback(
    CC_Mqtt5ClientHandle client,
    CC_Mqtt5SendOutputDataCb cb,
    void* data)
{
    clientFromHandle(client)->setSendOutputDataCallback(cb, data);
}

void cc_mqtt5_##NAME##client_set_gw_disconnect_report_callback(
    CC_Mqtt5ClientHandle client,
    CC_Mqtt5BrokerDisconnectReportCb cb,
    void* data)
{
    clientFromHandle(client)->setBrokerDisconnectReportCallback(cb, data);
}
