//
// Copyright 2023 - 2024 (C). Alex Robenko. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

/// @file
/// @brief Functions of MQTT5 client library.

#pragma once

#include "cc_mqtt5_client/common.h"

#ifdef __cplusplus
extern "C" {
#endif // #ifdef __cplusplus

/// @brief Allocate new client.
/// @details When work with the client is complete, @ref cc_mqtt5_##NAME##client_free()
///     function must be invoked.
/// @return Handle to allocated client object. This handle needs to be passed
///     as first parameter to all other API functions.
CC_Mqtt5ClientHandle cc_mqtt5_##NAME##client_new();

/// @brief Free previously allocated client.
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
/// @post The client handler becomes invalid and cannot be used any longer.
void cc_mqtt5_##NAME##client_free(CC_Mqtt5ClientHandle handle);

/// @brief (Re)Initialize client.
/// @details Re-initializes all internal data structures into their default variables
///     and checks that all the required callbacks have been set. If there are old
///     outstanding operations they are all aborted.
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_init(CC_Mqtt5ClientHandle handle);

bool cc_mqtt5_##NAME##client_is_initialized(CC_Mqtt5ClientHandle handle);

bool cc_mqtt5_##NAME##client_is_connected(CC_Mqtt5ClientHandle handle);

/// @brief Notify client about requested time expiry.
/// @details The reported amount of milliseconds needs to be from the 
///     last request to program timer via callback (set by
///     cc_mqtt5_##NAME##client_set_next_tick_program_callback()).
///     It can be less than actually requested via the callback. If this
///     function is called, the library assumes that previously requested
///     timeout measurement is not in progress any more, and will request
///     new measurement if needed.
///     This call may cause invocation of some other callbacks, such as a request
///     to send new data to the broker.
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
/// @param[in] ms Number of elapsed @b milliseconds.
void cc_mqtt5_##NAME##client_tick(CC_Mqtt5ClientHandle handle, unsigned ms);

/// @brief Provide data, received over I/O link, to the library for processing.
/// @details This call may cause invocation of some callbacks, such as 
///     request to cancel the currently running time measurement, send some messages to
///     the broker, report incoming application message, and (re)start time
///     measurement.
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
/// @param[in] buf Pointer to the buffer of data to process.
/// @param[in] bufLen Number of bytes in the data buffer.
/// @return Number of processed bytes.
/// @note The function returns number of bytes that were actually consumed, and
///     can be removed from the holding buffer.
unsigned cc_mqtt5_##NAME##client_process_data(CC_Mqtt5ClientHandle handle, const unsigned char* buf, unsigned bufLen);

CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_set_default_response_timeout(CC_Mqtt5ClientHandle handle, unsigned ms);
unsigned cc_mqtt5_##NAME##client_get_default_response_timeout(CC_Mqtt5ClientHandle handle);

CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_pub_topic_alias_alloc(CC_Mqtt5ClientHandle handle, const char* topic, unsigned char qos0RegsCount);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_pub_topic_alias_free(CC_Mqtt5ClientHandle handle, const char* topic);

CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_set_verify_outgoing_topic_enabled(CC_Mqtt5ClientHandle handle, bool enabled);
bool cc_mqtt5_##NAME##client_get_verify_outgoing_topic(CC_Mqtt5ClientHandle handle);

CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_set_verify_incoming_topic_enabled(CC_Mqtt5ClientHandle handle, bool enabled);
bool cc_mqtt5_##NAME##client_get_verify_incoming_topic(CC_Mqtt5ClientHandle handle);

void cc_mqtt5_##NAME##client_init_user_prop(CC_Mqtt5UserProp* prop);

CC_Mqtt5ConnectHandle cc_mqtt5_##NAME##client_connect_prepare(CC_Mqtt5ClientHandle handle, CC_Mqtt5ErrorCode* ec);
void cc_mqtt5_##NAME##client_connect_init_config_basic(CC_Mqtt5ConnectBasicConfig* config);
void cc_mqtt5_##NAME##client_connect_init_config_will(CC_Mqtt5ConnectWillConfig* config);
void cc_mqtt5_##NAME##client_connect_init_config_extra(CC_Mqtt5ConnectExtraConfig* config);
void cc_mqtt5_##NAME##client_connect_init_config_auth(CC_Mqtt5ConnectAuthConfig* config);
void cc_mqtt5_##NAME##client_connect_init_auth_info(CC_Mqtt5AuthInfo* info);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_set_response_timeout(CC_Mqtt5ConnectHandle handle, unsigned ms);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_config_basic(CC_Mqtt5ConnectHandle handle, const CC_Mqtt5ConnectBasicConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_config_will(CC_Mqtt5ConnectHandle handle, const CC_Mqtt5ConnectWillConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_config_extra(CC_Mqtt5ConnectHandle handle, const CC_Mqtt5ConnectExtraConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_config_auth(CC_Mqtt5ConnectHandle handle, const CC_Mqtt5ConnectAuthConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_add_user_prop(CC_Mqtt5ConnectHandle handle, const CC_Mqtt5UserProp* prop);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_connect_send(CC_Mqtt5ConnectHandle handle, CC_Mqtt5ConnectCompleteCb cb, void* cbData);

CC_Mqtt5DisconnectHandle cc_mqtt5_##NAME##client_disconnect_prepare(CC_Mqtt5ClientHandle handle, CC_Mqtt5ErrorCode* ec);
void cc_mqtt5_##NAME##client_disconnect_init_config(CC_Mqtt5DisconnectConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_diconnect_config(CC_Mqtt5DisconnectHandle handle, const CC_Mqtt5DisconnectConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_disconnect_add_user_prop(CC_Mqtt5DisconnectHandle handle, const CC_Mqtt5UserProp* prop);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_disconnect_send(CC_Mqtt5DisconnectHandle handle);

CC_Mqtt5SubscribeHandle cc_mqtt5_##NAME##client_subscribe_prepare(CC_Mqtt5ClientHandle handle, CC_Mqtt5ErrorCode* ec);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_subscribe_set_response_timeout(CC_Mqtt5SubscribeHandle handle, unsigned ms);
void cc_mqtt5_##NAME##client_subscribe_init_config_topic(CC_Mqtt5SubscribeTopicConfig* config);
void cc_mqtt5_##NAME##client_subscribe_init_config_extra(CC_Mqtt5SubscribeExtraConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_subscribe_config_topic(CC_Mqtt5SubscribeHandle handle, const CC_Mqtt5SubscribeTopicConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_subscribe_config_extra(CC_Mqtt5SubscribeHandle handle, const CC_Mqtt5SubscribeExtraConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_subscribe_add_user_prop(CC_Mqtt5SubscribeHandle handle, const CC_Mqtt5UserProp* prop);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_subscribe_send(CC_Mqtt5SubscribeHandle handle, CC_Mqtt5SubscribeCompleteCb cb, void* cbData);

CC_Mqtt5UnsubscribeHandle cc_mqtt5_##NAME##client_unsubscribe_prepare(CC_Mqtt5ClientHandle handle, CC_Mqtt5ErrorCode* ec);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_unsubscribe_set_response_timeout(CC_Mqtt5UnsubscribeHandle handle, unsigned ms);
void cc_mqtt5_##NAME##client_unsubscribe_init_config_topic(CC_Mqtt5UnsubscribeTopicConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_unsubscribe_config_topic(CC_Mqtt5UnsubscribeHandle handle, const CC_Mqtt5UnsubscribeTopicConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_unsubscribe_add_user_prop(CC_Mqtt5UnsubscribeHandle handle, const CC_Mqtt5UserProp* prop);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_unsubscribe_send(CC_Mqtt5UnsubscribeHandle handle, CC_Mqtt5UnsubscribeCompleteCb cb, void* cbData);

CC_Mqtt5PublishHandle cc_mqtt5_##NAME##client_publish_prepare(CC_Mqtt5ClientHandle handle, CC_Mqtt5ErrorCode* ec);
void cc_mqtt5_##NAME##client_publish_init_config_basic(CC_Mqtt5PublishBasicConfig* config);
void cc_mqtt5_##NAME##client_publish_init_config_extra(CC_Mqtt5PublishExtraConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_publish_set_response_timeout(CC_Mqtt5PublishHandle handle, unsigned ms);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_publish_set_resend_attempts(CC_Mqtt5PublishHandle handle, unsigned attempts);
unsigned cc_mqtt5_##NAME##client_publish_get_resend_attempts(CC_Mqtt5PublishHandle handle);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_publish_config_basic(CC_Mqtt5PublishHandle handle, const CC_Mqtt5PublishBasicConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_publish_config_extra(CC_Mqtt5PublishHandle handle, const CC_Mqtt5PublishExtraConfig* config);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_publish_add_user_prop(CC_Mqtt5PublishHandle handle, const CC_Mqtt5UserProp* prop);
CC_Mqtt5ErrorCode cc_mqtt5_##NAME##client_publish_send(CC_Mqtt5PublishHandle handle, CC_Mqtt5PublishCompleteCb cb, void* cbData);

// --------------------- Callbacks ---------------------

/// @brief Set callback to call when time measurement is required.
/// @details The MQTT5 client may require to measure time. When such 
///     measurement is required, the provided callback will be invoked with
///     the timeout duration in milliseconds. After requested time expires,
///     the @ref cc_mqtt5_##NAME##client_tick() function must be invoked.
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
/// @param[in] cb Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void cc_mqtt5_##NAME##client_set_next_tick_program_callback(
    CC_Mqtt5ClientHandle handle,
    CC_Mqtt5NextTickProgramCb cb,
    void* data);
    
/// @brief Set callback to terminate current time measurement.
/// @details The client may request termination of currently running time 
///     measurement, previously requested via callback, which was set using
///     @ref cc_mqtt5_##NAME##client_set_next_tick_program_callback() function. This function
///     sets appropriate callback. When invoked, it must return number of
///     elapsed milliseconds since previoius time measurement request.
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
/// @param[in] cb Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void cc_mqtt5_##NAME##client_set_cancel_next_tick_wait_callback(
    CC_Mqtt5ClientHandle handle,
    CC_Mqtt5CancelNextTickWaitCb cb,
    void* data);
    
/// @brief Set callback to send raw data over I/O link.
/// @details The callback is invoked when there is a need to send data
///     to the gateway. The callback is invoked for every single message
///     that need to be sent as a single datagram. 
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
/// @param[in] cb Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void cc_mqtt5_##NAME##client_set_send_output_data_callback(
    CC_Mqtt5ClientHandle handle,
    CC_Mqtt5SendOutputDataCb cb,
    void* data);

/// @brief Set callback to report unsolicited disconnection of the broker.
/// @param[in] client Handle returned by @ref cc_mqtt5_##NAME##client_new() function.
/// @param[in] cb Callback function.
/// @param[in] data Pointer to any user data structure. It will passed as one 
///     of the parameters in callback invocation. May be NULL.
void cc_mqtt5_##NAME##client_set_broker_disconnect_report_callback(
    CC_Mqtt5ClientHandle handle,
    CC_Mqtt5BrokerDisconnectReportCb cb,
    void* data);

void cc_mqtt5_##NAME##client_set_message_received_report_callback(
    CC_Mqtt5ClientHandle handle,
    CC_Mqtt5MessageReceivedReportCb cb,
    void* data);
    
void cc_mqtt5_##NAME##client_set_error_log_callback(
    CC_Mqtt5ClientHandle handle,
    CC_Mqtt5ErrorLogCb cb,
    void* data);

#ifdef __cplusplus
}
#endif
