#include "UnitTestCommonBase.h"
#include "UnitTestDefs.h"
#include "UnitTestPropsHandler.h"
#include "UnitTestProtocolDefs.h"

#include "client.h"

#include <cxxtest/TestSuite.h>

class UnitTestConnect : public CxxTest::TestSuite, public UnitTestCommonBase
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();

private:
    virtual void setUp() override
    {
        unitTestSetUp();
    }

    virtual void tearDown() override
    {
        unitTestTearDown();
    }
};

void UnitTestConnect::test1()
{
    // Simple connect and ack
    // [MQTT-3.1.2-1]
    // [MQTT-3.1.2-2]
    // [MQTT-3.1.2-11]
    // [MQTT-3.1.2-13]
    // [MQTT-3.1.2-16]
    // [MQTT-3.1.2-18]
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);

    const std::string ClientId("bla");
    const unsigned KeepAlive = 50;
    connectBasicConfig.m_clientId = ClientId.c_str();
    connectBasicConfig.m_keepAlive = KeepAlive;
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT_EQUALS(connectMsg->field_protocolName().value(), "MQTT");
    TS_ASSERT_EQUALS(connectMsg->field_protocolVersion().value(), 5U);
    TS_ASSERT(!connectMsg->field_flags().field_low().getBitValue_willFlag());
    TS_ASSERT_EQUALS(connectMsg->field_flags().field_willQos().value(), UnitTestConnectMsg::Field_flags::Field_willQos::ValueType::AtMostOnceDelivery);
    TS_ASSERT(!connectMsg->field_flags().field_high().getBitValue_willRetain());
    TS_ASSERT(!connectMsg->field_flags().field_high().getBitValue_userNameFlag());
    TS_ASSERT(!connectMsg->field_flags().field_high().getBitValue_passwordFlag());
    TS_ASSERT_EQUALS(connectMsg->field_clientId().value(), ClientId);
    TS_ASSERT_EQUALS(connectMsg->field_keepAlive().value(), KeepAlive);
    TS_ASSERT(connectMsg->field_flags().field_low().getBitValue_cleanStart());
    TS_ASSERT(connectMsg->field_willProperties().isMissing());
    TS_ASSERT(connectMsg->field_properties().value().empty());
    TS_ASSERT(connectMsg->field_willTopic().isMissing());
    TS_ASSERT(connectMsg->field_willMessage().isMissing());
    TS_ASSERT(connectMsg->field_userName().isMissing());
    TS_ASSERT(connectMsg->field_password().isMissing());
    TS_ASSERT(!unitTestIsConnectComplete());

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_maxQos, CC_Mqtt5QoS_ExactlyOnceDelivery);
    TS_ASSERT(!connectInfo.m_response.m_sessionPresent);
    TS_ASSERT(connectInfo.m_response.m_retainAvailable);
    TS_ASSERT(connectInfo.m_response.m_wildcardSubAvailable);
    TS_ASSERT(connectInfo.m_response.m_subIdsAvailable);
    TS_ASSERT(connectInfo.m_response.m_sharedSubsAvailable);
    unitTestPopConnectResponseInfo();

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, KeepAlive * 1000);
}

void UnitTestConnect::test2()
{
    // Testing connect properties and will
    // [MQTT-3.1.2-9]
    // [MQTT-3.1.2-17]
    // [MQTT-3.1.2-19]
    // [MQTT-3.1.2-21]
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);

    const std::string ClientId("bla");
    const std::string Username("username");
    const std::vector<std::uint8_t> Password = {0, 1, 2, 3, 4, 5};
    const unsigned KeepAlive = 50;
    connectBasicConfig.m_clientId = ClientId.c_str();
    connectBasicConfig.m_username = Username.c_str();
    connectBasicConfig.m_password = &Password[0];
    connectBasicConfig.m_passwordLen = static_cast<decltype(connectBasicConfig.m_passwordLen)>(Password.size());
    connectBasicConfig.m_keepAlive = KeepAlive;
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string WillTopic = "/will/topic";
    const std::vector<std::uint8_t> WillData = {1, 2, 3, 4, 5, 6, 7};
    const std::string WillContentType("SomeContentType");
    const std::string WillResponseTopic("ResponseTopic");
    const std::vector<std::uint8_t> WillCorrelationData = {0x1a, 0x2a, 0x3a, 0x4a, 0x5a, 0x6a, 0x7a};
    const unsigned WillDelayInterval = 10;
    const unsigned WillExpiryInterval = 100;
    const CC_Mqtt5QoS WillQos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    const CC_Mqtt5PayloadFormat WillFormat = CC_Mqtt5PayloadFormat_Utf8;
    const bool WillRetain = true;

    auto connectWillConfig = CC_Mqtt5ConnectWillConfig();
    cc_mqtt5_client_connect_init_config_will(&connectWillConfig);

    connectWillConfig.m_topic = WillTopic.c_str();
    connectWillConfig.m_data = &WillData[0];
    connectWillConfig.m_dataLen = static_cast<decltype(connectWillConfig.m_dataLen)>(WillData.size());
    connectWillConfig.m_contentType = WillContentType.c_str();
    connectWillConfig.m_responseTopic = WillResponseTopic.c_str();
    connectWillConfig.m_correlationData = &WillCorrelationData[0];
    connectWillConfig.m_correlationDataLen = static_cast<decltype(connectWillConfig.m_correlationDataLen)>(WillCorrelationData.size());
    connectWillConfig.m_delayInterval = WillDelayInterval;
    connectWillConfig.m_messageExpiryInterval = WillExpiryInterval;
    connectWillConfig.m_qos = WillQos;
    connectWillConfig.m_format = WillFormat;
    connectWillConfig.m_retain = WillRetain;    

    ec = cc_mqtt5_client_connect_config_will(connect, &connectWillConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const unsigned SessionExpiryInterval = 50;
    const unsigned ReceiveMaximum = 4096;
    const unsigned MaxPacketSize = 4096;
    const unsigned TopicAliasMax = 1024;
    const bool RequestResponseInfo = true;
    const bool RequestProblemInfo = true;

    auto connectExtraConfig = CC_Mqtt5ConnectExtraConfig();
    cc_mqtt5_client_connect_init_config_extra(&connectExtraConfig);

    connectExtraConfig.m_sessionExpiryInterval = SessionExpiryInterval;
    connectExtraConfig.m_receiveMaximum = ReceiveMaximum;
    connectExtraConfig.m_maxPacketSize = MaxPacketSize;
    connectExtraConfig.m_topicAliasMaximum = TopicAliasMax;
    connectExtraConfig.m_requestResponseInfo = RequestResponseInfo;
    connectExtraConfig.m_requestProblemInfo = RequestProblemInfo;    

    ec = cc_mqtt5_client_connect_config_extra(connect, &connectExtraConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string UserPropKey1 = "key1";
    const std::string UserPropVal1 = "val1";
    auto prop1 = CC_Mqtt5UserProp();
    prop1.m_key = UserPropKey1.c_str();
    prop1.m_value = UserPropVal1.c_str();
    ec = cc_mqtt5_client_connect_add_user_prop(connect, &prop1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);


    const std::string UserPropKey2 = "key2";
    const std::string UserPropVal2 = "val2";
    auto prop2 = CC_Mqtt5UserProp();
    prop2.m_key = UserPropKey2.c_str();
    prop2.m_value = UserPropVal2.c_str();
    ec = cc_mqtt5_client_connect_add_user_prop(connect, &prop2);    
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT_EQUALS(connectMsg->field_clientId().value(), ClientId);
    TS_ASSERT(connectMsg->field_flags().field_low().getBitValue_cleanStart());
    TS_ASSERT(connectMsg->field_flags().field_low().getBitValue_willFlag());
    TS_ASSERT_EQUALS(static_cast<decltype(WillQos)>(connectMsg->field_flags().field_willQos().value()), WillQos);
    TS_ASSERT(connectMsg->field_flags().field_high().getBitValue_userNameFlag());
    TS_ASSERT(connectMsg->field_flags().field_high().getBitValue_passwordFlag());
    TS_ASSERT_EQUALS(connectMsg->field_keepAlive().value(), KeepAlive);
    TS_ASSERT(connectMsg->field_willTopic().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_willTopic().field().value(), WillTopic);
    TS_ASSERT(connectMsg->field_willMessage().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_willMessage().field().value(), WillData);
    TS_ASSERT(connectMsg->field_userName().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_userName().field().value(), Username);
    TS_ASSERT(connectMsg->field_password().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_password().field().value(), Password);

    UnitTestPropsHandler propsHandler;
    for (auto& p : connectMsg->field_properties().value()) {
        p.currentFieldExec(propsHandler);
    }

    TS_ASSERT_DIFFERS(propsHandler.m_sessionExpiryInterval, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_sessionExpiryInterval->field_value().value(), SessionExpiryInterval);
    TS_ASSERT_DIFFERS(propsHandler.m_receiveMax, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_receiveMax->field_value().value(), ReceiveMaximum);
    TS_ASSERT_DIFFERS(propsHandler.m_maxPacketSize, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_maxPacketSize->field_value().value(), MaxPacketSize);
    TS_ASSERT_DIFFERS(propsHandler.m_topicAliasMax, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_topicAliasMax->field_value().value(), TopicAliasMax);
    TS_ASSERT_DIFFERS(propsHandler.m_requestResponseInfo, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_requestResponseInfo->field_value().value() == UnitTestPropsHandler::RequestResponseInfo::Field_value::ValueType::Enabled, RequestResponseInfo);
    TS_ASSERT_DIFFERS(propsHandler.m_requestProblemInfo, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_requestProblemInfo->field_value().value() == UnitTestPropsHandler::RequestProblemInfo::Field_value::ValueType::Enabled, RequestProblemInfo);
    TS_ASSERT_EQUALS(propsHandler.m_userProps.size(), 2U);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_first().value(), UserPropKey1);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_second().value(), UserPropVal1);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[1]->field_value().field_first().value(), UserPropKey2);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[1]->field_value().field_second().value(), UserPropVal2);    

    const std::string BrokerResponseInfo("BrokerResponse");
    const std::string BrokerReason("BrokerReason");
    const std::string BrokerServerRef("AnotherServer");
    const std::string BrokerPropKey1("broker_key1");
    const std::string BrokerPropVal1("broker_val1");
    const std::string BrokerPropKey2("broker_key2");
    const std::string BrokerPropVal2("broker_val2");

    const unsigned BrokerReceiveMax = 2222;
    const unsigned BrokerMaxPacketSize = 4444;
    const unsigned BrokerTopicAliasMax = 1000;
    const auto BrokerMaxQos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    const unsigned BrokerKeepAlive = 30;

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_flags().setBitValue_sp(false);
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    auto& propsVec = connackMsg.field_propertiesList().value();
    using ConnackProperty = UnitTestConnackMsg::Field_propertiesList::ValueType::value_type;
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_responseInfo();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerResponseInfo;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_reasonStr();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerReason;
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_serverRef();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerServerRef;
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_receiveMax();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerReceiveMax;
    } while (false);   

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_maxPacketSize();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerMaxPacketSize;
    } while (false);   

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_topicAliasMax();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerTopicAliasMax;
    } while (false);       

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_maxQos();
        auto& propValue = propBundle.field_value();
        comms::cast_assign(propValue.value()) = BrokerMaxQos;
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_retainAvailable();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_retainAvailable::Field_value::ValueType::Disabled;
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_wildcardSubAvail();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_wildcardSubAvail::Field_value::ValueType::Disabled;
    } while (false);  

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_subIdAvail();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_subIdAvail::Field_value::ValueType::Disabled;
    } while (false);        

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_sharedSubAvail();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_sharedSubAvail::Field_value::ValueType::Disabled;
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_userProperty();
        auto& propValue = propBundle.field_value();
        propValue.field_first().value() = BrokerPropKey1;
        propValue.field_second().value() = BrokerPropVal1;
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_userProperty();
        auto& propValue = propBundle.field_value();
        propValue.field_first().value() = BrokerPropKey2;
        propValue.field_second().value() = BrokerPropVal2;
    } while (false);           

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_serverKeepAlive();
        auto& propValue = propBundle.field_value();
        propValue.setValue(BrokerKeepAlive);
    } while (false);                 

    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    TS_ASSERT(connectInfo.m_response.m_assignedClientId.empty());
    TS_ASSERT_EQUALS(connectInfo.m_response.m_responseInfo, BrokerResponseInfo);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonStr, BrokerReason);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_serverRef, BrokerServerRef);
    TS_ASSERT(connectInfo.m_response.m_authData.empty());
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps.size(), 2U);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[0].m_key, BrokerPropKey1);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[0].m_value, BrokerPropVal1);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[1].m_key, BrokerPropKey2);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[1].m_value, BrokerPropVal2);    
    TS_ASSERT_EQUALS(connectInfo.m_response.m_sessionExpiryInterval, SessionExpiryInterval);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_highQosPubLimit, BrokerReceiveMax);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_maxPacketSize, BrokerMaxPacketSize);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_topicAliasMax, BrokerTopicAliasMax);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_maxQos, BrokerMaxQos);
    TS_ASSERT(!connectInfo.m_response.m_sessionPresent);
    TS_ASSERT(!connectInfo.m_response.m_retainAvailable);
    TS_ASSERT(!connectInfo.m_response.m_wildcardSubAvailable);
    TS_ASSERT(!connectInfo.m_response.m_subIdsAvailable);
    TS_ASSERT(!connectInfo.m_response.m_sharedSubsAvailable);
    unitTestPopConnectResponseInfo();

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, BrokerKeepAlive * 1000);
}

void UnitTestConnect::test3()
{
    // Connect with authentication
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnetAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnetAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());

    UnitTestPropsHandler propsHandler;
    for (auto& p : connectMsg->field_properties().value()) {
        p.currentFieldExec(propsHandler);
    }

    TS_ASSERT_DIFFERS(propsHandler.m_authMethod, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_authMethod->field_value().value(), ConnectAuthMethod);

    TS_ASSERT_DIFFERS(propsHandler.m_authData, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_authData->field_value().value(), ConnetAuthData);    
    
    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    const UnitTestData AuthData = {0x11, 0x22, 0x33, 0x44};
    const std::string AuthReasonStr = "AuthReason";
    const std::string AuthUserPropKey1 = "AuthKey1";
    const std::string AuthUserPropVal1 = "AuthVal1";
    const UnitTestUserProp::List AuthUserProps = {
        UnitTestUserProp{AuthUserPropKey1, AuthUserPropVal1}
    };

    UnitTestAuthInfo authOutInfo;
    authOutInfo.m_authData = AuthData;
    authOutInfo.m_reasonStr = AuthReasonStr;
    authOutInfo.m_userProps = AuthUserProps;
    unitTestAddOutAuth(authOutInfo);

    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};
    const std::string BrokerAuthReasonStr = "BrokerReason";
    const std::string BrokerAuthUserPropKey1 = "BrokerAuthKey1";
    const std::string BrokerAuthUserPropVal1 = "BrokerAuthVal1";
    UnitTestUserProp::List BrokerAuthUserProps = {
        UnitTestUserProp{BrokerAuthUserPropKey1, BrokerAuthUserPropVal1}
    };

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().value() = UnitTestAuthMsg::Field_reasonCode::ValueType::ContinueAuth;
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_reasonStr();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthReasonStr;
    } while (false);     

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_userProperty();
        auto& propValue = propBundle.field_value();
        propValue.field_first().value() = BrokerAuthUserPropKey1;
        propValue.field_second().value() = BrokerAuthUserPropVal1;
    } while (false);     
    
    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(!unitTestIsConnectComplete());

    auto& inAuthInfo = unitTestInAuthInfo();
    TS_ASSERT_EQUALS(inAuthInfo.m_authData, BrokerAuthData);
    TS_ASSERT_EQUALS(inAuthInfo.m_reasonStr, BrokerAuthReasonStr);
    TS_ASSERT_EQUALS(inAuthInfo.m_userProps.size(), 1U);
    TS_ASSERT_EQUALS(inAuthInfo.m_userProps[0].m_key, BrokerAuthUserPropKey1);
    TS_ASSERT_EQUALS(inAuthInfo.m_userProps[0].m_value, BrokerAuthUserPropVal1);
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Auth);
    auto* authMsg = dynamic_cast<UnitTestAuthMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(authMsg, nullptr);
    TS_ASSERT_EQUALS(authMsg->field_reasonCode().value(), UnitTestAuthMsg::Field_reasonCode::ValueType::ContinueAuth);

    UnitTestPropsHandler authPropsHandler;
    for (auto& p : authMsg->field_propertiesList().value()) {
        p.currentFieldExec(authPropsHandler);
    }    

    TS_ASSERT_DIFFERS(authPropsHandler.m_authMethod, nullptr);
    TS_ASSERT_EQUALS(authPropsHandler.m_authMethod->field_value().value(), ConnectAuthMethod);
    TS_ASSERT_DIFFERS(authPropsHandler.m_authData, nullptr);
    TS_ASSERT_EQUALS(authPropsHandler.m_authData->field_value().value(), AuthData);
    TS_ASSERT_DIFFERS(authPropsHandler.m_reasonStr, nullptr);
    TS_ASSERT_EQUALS(authPropsHandler.m_reasonStr->field_value().value(), AuthReasonStr);   
    TS_ASSERT_EQUALS(authPropsHandler.m_userProps.size(), 1U);
    TS_ASSERT_EQUALS(authPropsHandler.m_userProps[0]->field_value().field_first().value(), AuthUserPropKey1);
    TS_ASSERT_EQUALS(authPropsHandler.m_userProps[0]->field_value().field_second().value(), AuthUserPropVal1);

    unitTestTick(1000);
    const UnitTestData ConnackAuthData = {0x44, 0x55, 0x44, 0x55};
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    auto& connackPropsBec = connackMsg.field_propertiesList().value();
    do {
        connackPropsBec.resize(connackPropsBec.size() + 1U);
        auto& propVar = connackPropsBec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        connackPropsBec.resize(connackPropsBec.size() + 1U);
        auto& propVar = connackPropsBec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackAuthData;
    } while (false);        

    do {
        connackPropsBec.resize(connackPropsBec.size() + 1U);
        auto& propVar = connackPropsBec.back();
        auto& propBundle = propVar.initField_assignedClientId();
        auto& propValue = propBundle.field_value();
        propValue.value() = __FUNCTION__;
    } while (false);        

    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_authData, ConnackAuthData);
    unitTestPopConnectResponseInfo();    
}

void UnitTestConnect::test4()
{
    // Testing change of the Auth method, protocol error is expected
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnetAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnetAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    const std::string BrokerAuthMethod = "BrokerAuthMethod";
    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().value() = UnitTestAuthMsg::Field_reasonCode::ValueType::ContinueAuth;
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    

    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo();    

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Disconnect);
    auto* disconnectMsg = dynamic_cast<UnitTestDisconnectMsg*>(sentMsg.get());
    TS_ASSERT_EQUALS(disconnectMsg->field_reasonCode().field().value(), UnitTestDisconnectMsg::Field_reasonCode::Field::ValueType::ProtocolError);
}

void UnitTestConnect::test5()
{
    // Keep alive test
    // [MQTT-3.1.2-20]
    auto* client = unitTestAllocClient();
    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);

    const std::string ClientId("bla");
    const unsigned KeepAlive = 30;
    connectBasicConfig.m_clientId = ClientId.c_str();
    connectBasicConfig.m_keepAlive = KeepAlive;
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    unitTestPopConnectResponseInfo();

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, KeepAlive * 1000);

    TS_ASSERT(!unitTestIsDisconnected());

    unitTestTick();
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pingreq);
    TS_ASSERT(!unitTestIsDisconnected());

    const unsigned PingDelay = 1000;
    unitTestTick(PingDelay);
    UnitTestPingrespMsg pingrespMsg;
    unitTestReceiveMessage(pingrespMsg);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, KeepAlive * 1000 - PingDelay);

    // New ping is expected
    unitTestTick();
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pingreq);
    TS_ASSERT(!unitTestIsDisconnected());

    // No ping response
    unitTestTick(); // 1000
    TS_ASSERT(!unitTestHasSentMessage());
    unitTestTick();
    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(!unitTestHasDisconnectInfo());

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Disconnect);
    auto* disconnectMsg = dynamic_cast<UnitTestDisconnectMsg*>(sentMsg.get());
    TS_ASSERT_EQUALS(disconnectMsg->field_reasonCode().field().value(), UnitTestDisconnectMsg::Field_reasonCode::Field::ValueType::KeepAliveTimeout);
}

void UnitTestConnect::test6()
{
    // Testing inability to send any message before CONNECT.
    // [MQTT-3.1.0-1]
    auto* client = unitTestAllocClient();

    auto ec = CC_Mqtt5ErrorCode_ValuesLimit;
    auto* disconnect = ::cc_mqtt5_client_disconnect_prepare(client, &ec);
    TS_ASSERT_EQUALS(disconnect, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);

    auto* subscribe = ::cc_mqtt5_client_subscribe_prepare(client, &ec);    
    TS_ASSERT_EQUALS(subscribe, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);

    auto* unsubscribe = ::cc_mqtt5_client_unsubscribe_prepare(client, &ec);    
    TS_ASSERT_EQUALS(unsubscribe, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);    

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, &ec);    
    TS_ASSERT_EQUALS(publish, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);        
}

void UnitTestConnect::test7()
{
    // Testing attempt to send connect message second time
    // [MQTT-3.1.0-2]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    const std::string ClientId(__FUNCTION__);
    unitTestPerformBasicConnect(client, ClientId.c_str());

    // Second connection attempt
    auto ec = CC_Mqtt5ErrorCode_ValuesLimit;
    auto* connect = cc_mqtt5_client_connect_prepare(client, &ec);
    TS_ASSERT_EQUALS(connect, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_AlreadyConnected);        
}

void UnitTestConnect::test8()
{
    // Testing rejection of the non "clean start" on the first attempt to connect
    // [MQTT-3.1.2-4]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);
    
    auto config = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&config);

    config.m_clientId = __FUNCTION__;

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
}

void UnitTestConnect::test9()
{
    // Testing invalid will Qos
    // [MQTT-3.1.2-12]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);
    
    auto config = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&config);

    config.m_clientId = __FUNCTION__;
    config.m_cleanStart = true;

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto willConfig = CC_Mqtt5ConnectWillConfig();
    cc_mqtt5_client_connect_init_config_will(&willConfig);

    const UnitTestData WillData = {0x1, 0x2, 0x3};
    willConfig.m_topic = "will/topic";
    willConfig.m_data = &WillData[0];
    willConfig.m_dataLen = static_cast<decltype(willConfig.m_dataLen)>(WillData.size());
    willConfig.m_qos = static_cast<decltype(willConfig.m_qos)>(3);
    ec = cc_mqtt5_client_connect_config_will(connect, &willConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
}