#include "UnitTestCommonBase.h"
#include "UnitTestDefs.h"
#include "UnitTestPropsHandler.h"
#include "UnitTestProtocolDefs.h"

#include "client.h"

#include <cxxtest/TestSuite.h>

class UnitTestConnect : public CxxTest::TestSuite, public UnitTestCommonBase
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();
    void test26();
    void test27();
    void test28();
    void test29();
    void test30();
    void test31();
    void test32();

private:
    virtual void setUp() override
    {
        unitTestSetUp();
    }

    virtual void tearDown() override
    {
        unitTestTearDown();
    }
};

void UnitTestConnect::test1()
{
    // Simple connect and ack
    // [MQTT-3.1.2-1]
    // [MQTT-3.1.2-2]
    // [MQTT-3.1.2-11]
    // [MQTT-3.1.2-13]
    // [MQTT-3.1.2-16]
    // [MQTT-3.1.2-18]
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);

    const std::string ClientId("bla");
    const unsigned KeepAlive = 50;
    connectBasicConfig.m_clientId = ClientId.c_str();
    connectBasicConfig.m_keepAlive = KeepAlive;
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT_EQUALS(connectMsg->field_protocolName().value(), "MQTT");
    TS_ASSERT_EQUALS(connectMsg->field_protocolVersion().value(), 5U);
    TS_ASSERT(!connectMsg->field_flags().field_low().getBitValue_willFlag());
    TS_ASSERT_EQUALS(connectMsg->field_flags().field_willQos().value(), UnitTestConnectMsg::Field_flags::Field_willQos::ValueType::AtMostOnceDelivery);
    TS_ASSERT(!connectMsg->field_flags().field_high().getBitValue_willRetain());
    TS_ASSERT(!connectMsg->field_flags().field_high().getBitValue_userNameFlag());
    TS_ASSERT(!connectMsg->field_flags().field_high().getBitValue_passwordFlag());
    TS_ASSERT_EQUALS(connectMsg->field_clientId().value(), ClientId);
    TS_ASSERT_EQUALS(connectMsg->field_keepAlive().value(), KeepAlive);
    TS_ASSERT(connectMsg->field_flags().field_low().getBitValue_cleanStart());
    TS_ASSERT(connectMsg->field_willProperties().isMissing());
    TS_ASSERT(connectMsg->field_properties().value().empty());
    TS_ASSERT(connectMsg->field_willTopic().isMissing());
    TS_ASSERT(connectMsg->field_willMessage().isMissing());
    TS_ASSERT(connectMsg->field_userName().isMissing());
    TS_ASSERT(connectMsg->field_password().isMissing());
    TS_ASSERT(!unitTestIsConnectComplete());

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_maxQos, CC_Mqtt5QoS_ExactlyOnceDelivery);
    TS_ASSERT(!connectInfo.m_response.m_sessionPresent);
    TS_ASSERT(connectInfo.m_response.m_retainAvailable);
    TS_ASSERT(connectInfo.m_response.m_wildcardSubAvailable);
    TS_ASSERT(connectInfo.m_response.m_subIdsAvailable);
    TS_ASSERT(connectInfo.m_response.m_sharedSubsAvailable);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_highQosSendLimit, 65535U);
    unitTestPopConnectResponseInfo();

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, KeepAlive * 1000);
}

void UnitTestConnect::test2()
{
    // Testing connect properties and will
    // [MQTT-3.1.2-9]
    // [MQTT-3.1.2-17]
    // [MQTT-3.1.2-19]
    // [MQTT-3.1.2-21]
    // [MQTT-3.2.2-9]
    // [MQTT-3.2.2-21]
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);

    const std::string ClientId("bla");
    const std::string Username("username");
    const std::vector<std::uint8_t> Password = {0, 1, 2, 3, 4, 5};
    const unsigned KeepAlive = 50;
    connectBasicConfig.m_clientId = ClientId.c_str();
    connectBasicConfig.m_username = Username.c_str();
    connectBasicConfig.m_password = &Password[0];
    connectBasicConfig.m_passwordLen = static_cast<decltype(connectBasicConfig.m_passwordLen)>(Password.size());
    connectBasicConfig.m_keepAlive = KeepAlive;
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string WillTopic = "/will/topic";
    const std::vector<std::uint8_t> WillData = {1, 2, 3, 4, 5, 6, 7};
    const std::string WillContentType("SomeContentType");
    const std::string WillResponseTopic("ResponseTopic");
    const std::vector<std::uint8_t> WillCorrelationData = {0x1a, 0x2a, 0x3a, 0x4a, 0x5a, 0x6a, 0x7a};
    const unsigned WillDelayInterval = 10;
    const unsigned WillExpiryInterval = 100;
    const CC_Mqtt5QoS WillQos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    const CC_Mqtt5PayloadFormat WillFormat = CC_Mqtt5PayloadFormat_Utf8;
    const bool WillRetain = true;

    auto connectWillConfig = CC_Mqtt5ConnectWillConfig();
    cc_mqtt5_client_connect_init_config_will(&connectWillConfig);

    connectWillConfig.m_topic = WillTopic.c_str();
    connectWillConfig.m_data = &WillData[0];
    connectWillConfig.m_dataLen = static_cast<decltype(connectWillConfig.m_dataLen)>(WillData.size());
    connectWillConfig.m_contentType = WillContentType.c_str();
    connectWillConfig.m_responseTopic = WillResponseTopic.c_str();
    connectWillConfig.m_correlationData = &WillCorrelationData[0];
    connectWillConfig.m_correlationDataLen = static_cast<decltype(connectWillConfig.m_correlationDataLen)>(WillCorrelationData.size());
    connectWillConfig.m_delayInterval = WillDelayInterval;
    connectWillConfig.m_messageExpiryInterval = WillExpiryInterval;
    connectWillConfig.m_qos = WillQos;
    connectWillConfig.m_format = WillFormat;
    connectWillConfig.m_retain = WillRetain;    

    ec = cc_mqtt5_client_connect_config_will(connect, &connectWillConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const unsigned SessionExpiryInterval = 50;
    const unsigned ReceiveMaximum = 4096;
    const unsigned MaxPacketSize = 4096;
    const unsigned TopicAliasMax = 1024;
    const bool RequestResponseInfo = true;
    const bool RequestProblemInfo = true;

    auto connectExtraConfig = CC_Mqtt5ConnectExtraConfig();
    cc_mqtt5_client_connect_init_config_extra(&connectExtraConfig);

    connectExtraConfig.m_sessionExpiryInterval = SessionExpiryInterval;
    connectExtraConfig.m_receiveMaximum = ReceiveMaximum;
    connectExtraConfig.m_maxPacketSize = MaxPacketSize;
    connectExtraConfig.m_topicAliasMaximum = TopicAliasMax;
    connectExtraConfig.m_requestResponseInfo = RequestResponseInfo;
    connectExtraConfig.m_requestProblemInfo = RequestProblemInfo;    

    ec = cc_mqtt5_client_connect_config_extra(connect, &connectExtraConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string UserPropKey1 = "key1";
    const std::string UserPropVal1 = "val1";
    auto prop1 = CC_Mqtt5UserProp();
    prop1.m_key = UserPropKey1.c_str();
    prop1.m_value = UserPropVal1.c_str();
    ec = cc_mqtt5_client_connect_add_user_prop(connect, &prop1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);


    const std::string UserPropKey2 = "key2";
    const std::string UserPropVal2 = "val2";
    auto prop2 = CC_Mqtt5UserProp();
    prop2.m_key = UserPropKey2.c_str();
    prop2.m_value = UserPropVal2.c_str();
    ec = cc_mqtt5_client_connect_add_user_prop(connect, &prop2);    
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT_EQUALS(connectMsg->field_clientId().value(), ClientId);
    TS_ASSERT(connectMsg->field_flags().field_low().getBitValue_cleanStart());
    TS_ASSERT(connectMsg->field_flags().field_low().getBitValue_willFlag());
    TS_ASSERT_EQUALS(static_cast<decltype(WillQos)>(connectMsg->field_flags().field_willQos().value()), WillQos);
    TS_ASSERT(connectMsg->field_flags().field_high().getBitValue_userNameFlag());
    TS_ASSERT(connectMsg->field_flags().field_high().getBitValue_passwordFlag());
    TS_ASSERT_EQUALS(connectMsg->field_keepAlive().value(), KeepAlive);
    TS_ASSERT(connectMsg->field_willTopic().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_willTopic().field().value(), WillTopic);
    TS_ASSERT(connectMsg->field_willMessage().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_willMessage().field().value(), WillData);
    TS_ASSERT(connectMsg->field_userName().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_userName().field().value(), Username);
    TS_ASSERT(connectMsg->field_password().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_password().field().value(), Password);

    UnitTestPropsHandler propsHandler;
    for (auto& p : connectMsg->field_properties().value()) {
        p.currentFieldExec(propsHandler);
    }

    TS_ASSERT_DIFFERS(propsHandler.m_sessionExpiryInterval, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_sessionExpiryInterval->field_value().value(), SessionExpiryInterval);
    TS_ASSERT_DIFFERS(propsHandler.m_receiveMax, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_receiveMax->field_value().value(), ReceiveMaximum);
    TS_ASSERT_DIFFERS(propsHandler.m_maxPacketSize, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_maxPacketSize->field_value().value(), MaxPacketSize);
    TS_ASSERT_DIFFERS(propsHandler.m_topicAliasMax, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_topicAliasMax->field_value().value(), TopicAliasMax);
    TS_ASSERT_DIFFERS(propsHandler.m_requestResponseInfo, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_requestResponseInfo->field_value().value() == UnitTestPropsHandler::RequestResponseInfo::Field_value::ValueType::Enabled, RequestResponseInfo);
    TS_ASSERT_DIFFERS(propsHandler.m_requestProblemInfo, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_requestProblemInfo->field_value().value() == UnitTestPropsHandler::RequestProblemInfo::Field_value::ValueType::Enabled, RequestProblemInfo);
    TS_ASSERT_EQUALS(propsHandler.m_userProps.size(), 2U);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_first().value(), UserPropKey1);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_second().value(), UserPropVal1);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[1]->field_value().field_first().value(), UserPropKey2);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[1]->field_value().field_second().value(), UserPropVal2);    

    const std::string BrokerResponseInfo("BrokerResponse");
    const std::string BrokerReason("BrokerReason");
    const std::string BrokerServerRef("AnotherServer");
    const std::string BrokerPropKey1("broker_key1");
    const std::string BrokerPropVal1("broker_val1");
    const std::string BrokerPropKey2("broker_key2");
    const std::string BrokerPropVal2("broker_val2");

    const unsigned BrokerReceiveMax = 2222;
    const unsigned BrokerMaxPacketSize = 4444;
    const unsigned BrokerTopicAliasMax = 1000;
    const auto BrokerMaxQos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    const unsigned BrokerKeepAlive = 30;

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_flags().setBitValue_sp(false);
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    auto& propsVec = connackMsg.field_propertiesList().value();
    using ConnackProperty = UnitTestConnackMsg::Field_propertiesList::ValueType::value_type;
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_responseInfo();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerResponseInfo;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_reasonStr();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerReason;
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_serverRef();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerServerRef;
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_receiveMax();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerReceiveMax;
    } while (false);   

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_maxPacketSize();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerMaxPacketSize;
    } while (false);   

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_topicAliasMax();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerTopicAliasMax;
    } while (false);       

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_maxQos();
        auto& propValue = propBundle.field_value();
        comms::cast_assign(propValue.value()) = BrokerMaxQos;
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_retainAvailable();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_retainAvailable::Field_value::ValueType::Disabled;
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_wildcardSubAvail();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_wildcardSubAvail::Field_value::ValueType::Disabled;
    } while (false);  

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_subIdAvail();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_subIdAvail::Field_value::ValueType::Disabled;
    } while (false);        

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_sharedSubAvail();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackProperty::Field_sharedSubAvail::Field_value::ValueType::Disabled;
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_userProperty();
        auto& propValue = propBundle.field_value();
        propValue.field_first().value() = BrokerPropKey1;
        propValue.field_second().value() = BrokerPropVal1;
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_userProperty();
        auto& propValue = propBundle.field_value();
        propValue.field_first().value() = BrokerPropKey2;
        propValue.field_second().value() = BrokerPropVal2;
    } while (false);           

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& propVar = propsVec.back();
        auto& propBundle = propVar.initField_serverKeepAlive();
        auto& propValue = propBundle.field_value();
        propValue.setValue(BrokerKeepAlive);
    } while (false);                 

    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    TS_ASSERT(connectInfo.m_response.m_assignedClientId.empty());
    TS_ASSERT_EQUALS(connectInfo.m_response.m_responseInfo, BrokerResponseInfo);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonStr, BrokerReason);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_serverRef, BrokerServerRef);
    TS_ASSERT(connectInfo.m_response.m_authData.empty());
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps.size(), 2U);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[0].m_key, BrokerPropKey1);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[0].m_value, BrokerPropVal1);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[1].m_key, BrokerPropKey2);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_userProps[1].m_value, BrokerPropVal2);    
    TS_ASSERT_EQUALS(connectInfo.m_response.m_sessionExpiryInterval, SessionExpiryInterval);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_highQosSendLimit, BrokerReceiveMax);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_maxPacketSize, BrokerMaxPacketSize);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_topicAliasMax, BrokerTopicAliasMax);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_maxQos, BrokerMaxQos);
    TS_ASSERT(!connectInfo.m_response.m_sessionPresent);
    TS_ASSERT(!connectInfo.m_response.m_retainAvailable);
    TS_ASSERT(!connectInfo.m_response.m_wildcardSubAvailable);
    TS_ASSERT(!connectInfo.m_response.m_subIdsAvailable);
    TS_ASSERT(!connectInfo.m_response.m_sharedSubsAvailable);
    unitTestPopConnectResponseInfo();

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, BrokerKeepAlive * 1000);
}

void UnitTestConnect::test3()
{
    // Connect with authentication
    // [MQTT-4.12.0-2]
    // [MQTT-4.12.0-3]
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnectAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto connectExtraConfig = CC_Mqtt5ConnectExtraConfig();
    cc_mqtt5_client_connect_init_config_extra(&connectExtraConfig);
    connectExtraConfig.m_requestProblemInfo = true;    
    ec = cc_mqtt5_client_connect_config_extra(connect, &connectExtraConfig);    

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());

    UnitTestPropsHandler propsHandler;
    for (auto& p : connectMsg->field_properties().value()) {
        p.currentFieldExec(propsHandler);
    }

    TS_ASSERT_DIFFERS(propsHandler.m_authMethod, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_authMethod->field_value().value(), ConnectAuthMethod);

    TS_ASSERT_DIFFERS(propsHandler.m_authData, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_authData->field_value().value(), ConnectAuthData);    
    
    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    const UnitTestData AuthData = {0x11, 0x22, 0x33, 0x44};
    const std::string AuthReasonStr = "AuthReason";
    const std::string AuthUserPropKey1 = "AuthKey1";
    const std::string AuthUserPropVal1 = "AuthVal1";
    const UnitTestUserProp::List AuthUserProps = {
        UnitTestUserProp{AuthUserPropKey1, AuthUserPropVal1}
    };

    UnitTestAuthInfo authOutInfo;
    authOutInfo.m_authData = AuthData;
    authOutInfo.m_reasonStr = AuthReasonStr;
    authOutInfo.m_userProps = AuthUserProps;
    unitTestAddOutAuth(authOutInfo);

    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};
    const std::string BrokerAuthReasonStr = "BrokerReason";
    const std::string BrokerAuthUserPropKey1 = "BrokerAuthKey1";
    const std::string BrokerAuthUserPropVal1 = "BrokerAuthVal1";
    UnitTestUserProp::List BrokerAuthUserProps = {
        UnitTestUserProp{BrokerAuthUserPropKey1, BrokerAuthUserPropVal1}
    };

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_reasonStr();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthReasonStr;
    } while (false);     

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_userProperty();
        auto& propValue = propBundle.field_value();
        propValue.field_first().value() = BrokerAuthUserPropKey1;
        propValue.field_second().value() = BrokerAuthUserPropVal1;
    } while (false);     
    
    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(!unitTestIsConnectComplete());

    auto& inAuthInfo = unitTestInAuthInfo();
    TS_ASSERT_EQUALS(inAuthInfo.m_authData, BrokerAuthData);
    TS_ASSERT_EQUALS(inAuthInfo.m_reasonStr, BrokerAuthReasonStr);
    TS_ASSERT_EQUALS(inAuthInfo.m_userProps.size(), 1U);
    TS_ASSERT_EQUALS(inAuthInfo.m_userProps[0].m_key, BrokerAuthUserPropKey1);
    TS_ASSERT_EQUALS(inAuthInfo.m_userProps[0].m_value, BrokerAuthUserPropVal1);
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Auth);
    auto* authMsg = dynamic_cast<UnitTestAuthMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(authMsg, nullptr);
    TS_ASSERT(authMsg->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(authMsg->field_reasonCode().field().value(), UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth);

    TS_ASSERT(authMsg->field_propertiesList().doesExist());
    UnitTestPropsHandler authPropsHandler;
    for (auto& p : authMsg->field_propertiesList().field().value()) {
        p.currentFieldExec(authPropsHandler);
    }    

    TS_ASSERT_DIFFERS(authPropsHandler.m_authMethod, nullptr);
    TS_ASSERT_EQUALS(authPropsHandler.m_authMethod->field_value().value(), ConnectAuthMethod);
    TS_ASSERT_DIFFERS(authPropsHandler.m_authData, nullptr);
    TS_ASSERT_EQUALS(authPropsHandler.m_authData->field_value().value(), AuthData);
    TS_ASSERT_DIFFERS(authPropsHandler.m_reasonStr, nullptr);
    TS_ASSERT_EQUALS(authPropsHandler.m_reasonStr->field_value().value(), AuthReasonStr);   
    TS_ASSERT_EQUALS(authPropsHandler.m_userProps.size(), 1U);
    TS_ASSERT_EQUALS(authPropsHandler.m_userProps[0]->field_value().field_first().value(), AuthUserPropKey1);
    TS_ASSERT_EQUALS(authPropsHandler.m_userProps[0]->field_value().field_second().value(), AuthUserPropVal1);

    unitTestTick(1000);
    const UnitTestData ConnackAuthData = {0x44, 0x55, 0x44, 0x55};
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    auto& connackPropsVec = connackMsg.field_propertiesList().value();
    do {
        connackPropsVec.resize(connackPropsVec.size() + 1U);
        auto& propVar = connackPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        connackPropsVec.resize(connackPropsVec.size() + 1U);
        auto& propVar = connackPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnackAuthData;
    } while (false);        

    do {
        connackPropsVec.resize(connackPropsVec.size() + 1U);
        auto& propVar = connackPropsVec.back();
        auto& propBundle = propVar.initField_assignedClientId();
        auto& propValue = propBundle.field_value();
        propValue.value() = __FUNCTION__;
    } while (false);        

    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_authData, ConnackAuthData);
    unitTestPopConnectResponseInfo();    
}

void UnitTestConnect::test4()
{
    // Testing change of the Auth method, protocol error is expected
    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnectAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    const std::string BrokerAuthMethod = "BrokerAuthMethod";
    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    

    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo();    

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
}

void UnitTestConnect::test5()
{
    // Keep alive test
    // [MQTT-3.1.2-20]
    // [MQTT-3.12.4-1]
    auto* client = unitTestAllocClient();
    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);

    const std::string ClientId("bla");
    const unsigned KeepAlive = 30;
    connectBasicConfig.m_clientId = ClientId.c_str();
    connectBasicConfig.m_keepAlive = KeepAlive;
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, UnitTestDefaultOpTimeoutMs);

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_Success);
    unitTestPopConnectResponseInfo();

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, KeepAlive * 1000);

    TS_ASSERT(!unitTestIsDisconnected());

    unitTestTick();
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pingreq);
    TS_ASSERT(!unitTestIsDisconnected());

    const unsigned PingDelay = 1000;
    unitTestTick(PingDelay);
    UnitTestPingrespMsg pingrespMsg;
    unitTestReceiveMessage(pingrespMsg);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, KeepAlive * 1000 - PingDelay);

    // New ping is expected
    unitTestTick();
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pingreq);
    TS_ASSERT(!unitTestIsDisconnected());

    // No ping response
    unitTestTick(); // 1000
    TS_ASSERT(!unitTestHasSentMessage());
    unitTestTick();
    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(!unitTestHasDisconnectInfo());

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::KeepAliveTimeout);
}

void UnitTestConnect::test6()
{
    // Testing inability to send any message before CONNECT.
    // [MQTT-3.1.0-1]
    auto* client = unitTestAllocClient();

    auto ec = CC_Mqtt5ErrorCode_ValuesLimit;
    auto* disconnect = ::cc_mqtt5_client_disconnect_prepare(client, &ec);
    TS_ASSERT_EQUALS(disconnect, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);

    auto* subscribe = ::cc_mqtt5_client_subscribe_prepare(client, &ec);    
    TS_ASSERT_EQUALS(subscribe, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);

    auto* unsubscribe = ::cc_mqtt5_client_unsubscribe_prepare(client, &ec);    
    TS_ASSERT_EQUALS(unsubscribe, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);    

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, &ec);    
    TS_ASSERT_EQUALS(publish, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);        

    auto* reauth = ::cc_mqtt5_client_reauth_prepare(client, &ec);    
    TS_ASSERT_EQUALS(reauth, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);      
}

void UnitTestConnect::test7()
{
    // Testing attempt to send connect message second time
    // [MQTT-3.1.0-2]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    const std::string ClientId(__FUNCTION__);
    unitTestPerformBasicConnect(client, ClientId.c_str());

    // Second connection attempt
    auto ec = CC_Mqtt5ErrorCode_ValuesLimit;
    auto* connect = cc_mqtt5_client_connect_prepare(client, &ec);
    TS_ASSERT_EQUALS(connect, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_AlreadyConnected);        
}

void UnitTestConnect::test8()
{
    // Testing rejection of the non "clean start" on the first attempt to connect
    // [MQTT-3.1.2-4]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);
    
    auto config = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&config);

    config.m_clientId = __FUNCTION__;

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
}

void UnitTestConnect::test9()
{
    // Testing invalid will Qos
    // [MQTT-3.1.2-12]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);
    
    auto config = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&config);

    config.m_clientId = __FUNCTION__;
    config.m_cleanStart = true;

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto willConfig = CC_Mqtt5ConnectWillConfig();
    cc_mqtt5_client_connect_init_config_will(&willConfig);

    const UnitTestData WillData = {0x1, 0x2, 0x3};
    willConfig.m_topic = "will/topic";
    willConfig.m_data = &WillData[0];
    willConfig.m_dataLen = static_cast<decltype(willConfig.m_dataLen)>(WillData.size());
    willConfig.m_qos = static_cast<decltype(willConfig.m_qos)>(3);
    ec = cc_mqtt5_client_connect_config_will(connect, &willConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
}

void UnitTestConnect::test10()
{
    // Testing network disconnection during connect
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);
    
    auto config = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&config);

    config.m_clientId = __FUNCTION__;
    config.m_cleanStart = true;

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);

    unitTestTick(1000);
    ::cc_mqtt5_client_notify_network_disconnected(client, true);

    TS_ASSERT(unitTestIsConnectComplete());
    auto& connackInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connackInfo.m_status, CC_Mqtt5AsyncOpStatus_BrokerDisconnected);
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    // New connection attempt when network is disconnected
    connect = cc_mqtt5_client_connect_prepare(client, &ec);
    TS_ASSERT_EQUALS(connect, nullptr);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NetworkDisconnected);
}

void UnitTestConnect::test11()
{
    // Delaying keep alive ping when network is disconnected
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocClient();
    TS_ASSERT(!::cc_mqtt5_client_is_connected(client));

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, 60000); // Default keep alive - 60 seconds

    unitTestTick(10000); // 10 seconds

    ::cc_mqtt5_client_notify_network_disconnected(client, true);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(5000); // 5 seconds
    ::cc_mqtt5_client_notify_network_disconnected(client, false);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, 50000); // Remaining period of the keep alive

    unitTestTick(45000); // 45 seconds
    ::cc_mqtt5_client_notify_network_disconnected(client, true);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    TS_ASSERT(!unitTestIsDisconnected());
    unitTestTick(); // Session expiry timeout
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestConnect::test12()
{
    // Testing rejection of "Reason String" in AUTH
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    const std::string AuthMethod("AuthMethod");
    const UnitTestData AuthData = {0x11, 0x22, 0x33};

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, AuthMethod, AuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = AuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = AuthData;
    } while (false);    

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_reasonStr();
        auto& propValue = propBundle.field_value();
        propValue.value() = "ReasonStr";
    } while (false);     

    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo();    
    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
}

void UnitTestConnect::test13()
{
    // Testing rejection of "User properties" in AUTH
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    const std::string AuthMethod("AuthMethod");
    const UnitTestData AuthData = {0x11, 0x22, 0x33};

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, AuthMethod, AuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = AuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = AuthData;
    } while (false);    

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_userProperty();
        auto& propValue = propBundle.field_value();
        propValue.field_first().value() = "key1";
        propValue.field_second().value() = "val1";
    } while (false);    

    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo();    
    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
}

void UnitTestConnect::test14()
{
    // Testing rejection of connection with "Client ID not valid"
    // [MQTT-3.1.3-8]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_cleanStart = true;

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT(connectMsg->field_clientId().value().empty());

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::ClientIdInvalid;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_ClientIdInvalid);
    unitTestPopConnectResponseInfo();

    TS_ASSERT(!cc_mqtt5_client_is_connected(client));
}

void UnitTestConnect::test15()
{
    // Testing reception of DISCONNECT instead of CONNACK
    // [MQTT-3.1.4-1]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    unitTestTick(1000);
    UnitTestDisconnectMsg disconnectMsg;
    disconnectMsg.field_reasonCode().setExists();
    disconnectMsg.field_propertiesList().setExists();
    disconnectMsg.field_reasonCode().field().value() = UnitTestDisconnectMsg::Field_reasonCode::Field::ValueType::ImplSpecificError;
    unitTestReceiveMessage(disconnectMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_BrokerDisconnected);
    unitTestPopConnectResponseInfo();

    TS_ASSERT(!cc_mqtt5_client_is_connected(client));

    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(unitTestHasDisconnectInfo());
    auto disconnectInfo = unitTestDisconnectInfo();
    TS_ASSERT_EQUALS(disconnectInfo.m_reasonCode, CC_Mqtt5ReasonCode_ImplSpecificError);
    unitTestPopDisconnectInfo();
}

void UnitTestConnect::test16()
{
    // Testing network disconnection after rejecting connect
    // [MQTT-3.1.4-2]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    cc_mqtt5_client_connect_init_config_extra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = cc_mqtt5_client_connect_config_extra(connect, &extraConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::UnspecifiedError;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_UnspecifiedError);
    unitTestPopConnectResponseInfo();

    TS_ASSERT(!cc_mqtt5_client_is_connected(client));

    TS_ASSERT(unitTestCheckNoTicks());
    ::cc_mqtt5_client_notify_network_disconnected(client, true); 
}

void UnitTestConnect::test17()
{
    // Testing session taken over disconnection after successful connection.
    // [MQTT-3.1.4-3]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);

    unitTestTick(1000);
    UnitTestDisconnectMsg disconnectMsg;
    disconnectMsg.field_reasonCode().setExists();
    disconnectMsg.field_reasonCode().field().value() = UnitTestDisconnectMsg::Field_reasonCode::Field::ValueType::SessionTakenOver;
    unitTestReceiveMessage(disconnectMsg);

    TS_ASSERT(unitTestIsDisconnected());
    TS_ASSERT(unitTestHasDisconnectInfo());
    auto& disconnectInfo = unitTestDisconnectInfo();
    TS_ASSERT_EQUALS(disconnectInfo.m_reasonCode, CC_Mqtt5ReasonCode_SessionTakenOver);

    TS_ASSERT(!cc_mqtt5_client_is_initialized(client)); // Re-init is required.
}

void UnitTestConnect::test18()
{
    // Testing reception of the session present when clean was requested
    // [MQTT-3.2.2-4]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::UnspecifiedError;
    connackMsg.field_flags().setBitValue_sp(true);
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo();

    TS_ASSERT(!cc_mqtt5_client_is_connected(client));
}

void UnitTestConnect::test19()
{
    // Testing cleared subscription when clean state is reported.
    // [MQTT-3.2.2-5]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    unitTestPerformBasicSubscribe(client, "#");

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};

    UnitTestPublishMsg publishMsg;
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    unitTestPopReceivedMessageInfo();    

    unitTestTick(1000);
    unitTestPerformBasicDisconnect(client);

    TS_ASSERT(unitTestCheckNoTicks());

    auto ec = ::cc_mqtt5_client_init(client);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    // Reconnecting requesting non clean start, while broker reports session is not present
    unitTestPerformBasicConnect(client, __FUNCTION__, false);

    // Publish message is expected to be ignored
    unitTestReceiveMessage(publishMsg);
    TS_ASSERT(!unitTestHasMessageRecieved());
}

void UnitTestConnect::test20()
{
    // Testing rejecting CONNACK with network disconnection
    // [MQTT-3.2.2-7]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_reasonCode = CC_Mqtt5ReasonCode_UnspecifiedError;

    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);
    TS_ASSERT(!cc_mqtt5_client_is_connected(client));
    TS_ASSERT(!cc_mqtt5_client_is_network_disconnected(client));
    cc_mqtt5_client_notify_network_disconnected(client, true);
    TS_ASSERT(cc_mqtt5_client_is_network_disconnected(client));
    cc_mqtt5_client_init(client);
    TS_ASSERT(!cc_mqtt5_client_is_network_disconnected(client));
}

void UnitTestConnect::test21()
{
    // Testing report of the max Qos by the broker
    // [MQTT-3.2.2-9]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_maxQos = CC_Mqtt5QoS_AtMostOnceDelivery;
    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);
    TS_ASSERT(cc_mqtt5_client_is_connected(client));
}

void UnitTestConnect::test22()
{
    // Testing rejection of connection with "QoS not supported"
    // [MQTT-3.2.2-12]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_cleanStart = true;

    const std::string WillTopic = "will/topic";
    const UnitTestData WillData = {0x1, 0x2, 0x3};
    auto willConfig = CC_Mqtt5ConnectWillConfig();
    cc_mqtt5_client_connect_init_config_will(&willConfig);
    willConfig.m_topic = WillTopic.c_str();
    willConfig.m_data = &WillData[0];
    willConfig.m_dataLen = static_cast<unsigned>(WillData.size());
    willConfig.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;    

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = cc_mqtt5_client_connect_config_will(connect, &willConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT(connectMsg->field_willTopic().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_willTopic().field().value(), WillTopic);
    TS_ASSERT(connectMsg->field_willMessage().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_willMessage().field().value(), WillData);

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::QosNotSupported;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_QosNotSupported);
    unitTestPopConnectResponseInfo();

    TS_ASSERT(!cc_mqtt5_client_is_connected(client));
}

void UnitTestConnect::test23()
{
    // Testing rejection of connection with "QoS not supported"
    // [MQTT-3.2.2-13]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_cleanStart = true;

    const std::string WillTopic = "will/topic";
    const UnitTestData WillData = {0x1, 0x2, 0x3};
    auto willConfig = CC_Mqtt5ConnectWillConfig();
    cc_mqtt5_client_connect_init_config_will(&willConfig);
    willConfig.m_topic = WillTopic.c_str();
    willConfig.m_data = &WillData[0];
    willConfig.m_dataLen = static_cast<unsigned>(WillData.size());
    willConfig.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;    
    willConfig.m_retain = true;

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = cc_mqtt5_client_connect_config_will(connect, &willConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT(connectMsg->field_willTopic().doesExist());
    TS_ASSERT_EQUALS(connectMsg->field_willTopic().field().value(), WillTopic);
    TS_ASSERT(connectMsg->field_willMessage().doesExist());
    TS_ASSERT(connectMsg->field_flags().field_high().getBitValue_willRetain());

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::RetainNotSupported;
    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_RetainNotSupported);
    unitTestPopConnectResponseInfo();

    TS_ASSERT(!cc_mqtt5_client_is_connected(client));
}

void UnitTestConnect::test24()
{
    // Test allocation of the client id by the broker
    // Require clean start for empty client id
    // [MQTT-3.2.2-16]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_cleanStart = true;   

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsConnectComplete());    

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    TS_ASSERT(connectMsg->field_clientId().value().empty());
    
    const std::string BrokerClientId = __FUNCTION__;

    unitTestTick(1000);
    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::Success;
    auto& propsVec = connackMsg.field_propertiesList().value();
    {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_assignedClientId();
        field.field_value().value() = BrokerClientId;
    }

    unitTestReceiveMessage(connackMsg);

    TS_ASSERT(unitTestIsConnectComplete());   
    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_assignedClientId, BrokerClientId);
    unitTestPopConnectResponseInfo();
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    unitTestPerformBasicDisconnect(client);

    TS_ASSERT(unitTestCheckNoTicks());

    ec = ::cc_mqtt5_client_init(client);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    basicConfig.m_cleanStart = false;   
    
    connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    basicConfig.m_clientId = BrokerClientId.c_str();
    ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
}

void UnitTestConnect::test25()
{
    // Testing topic alias allocation
    // [MQTT-3.2.2-17]

    auto* client = unitTestAllocClient();

    auto ec = cc_mqtt5_client_pub_topic_alias_alloc(client, "topic1", 1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_NotConnected);

    unitTestPerformPubTopicAliasConnect(client, __FUNCTION__, 2);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    ec = cc_mqtt5_client_pub_topic_alias_alloc(client, "topic1", 1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = cc_mqtt5_client_pub_topic_alias_alloc(client, "topic2", 1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = cc_mqtt5_client_pub_topic_alias_alloc(client, "topic3", 1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
}

void UnitTestConnect::test26()
{
    // Testing topic alias allocation when broker doesn't support aliases
    // [MQTT-3.2.2-18]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto ec = cc_mqtt5_client_pub_topic_alias_alloc(client, "topic1", 1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
}

void UnitTestConnect::test27()
{
    // Testing invalid flags for AUTH message.
    // [MQTT-3.15.1-1]

    auto* client = unitTestAllocClient();

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnectAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    
    const UnitTestData BrokerAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.transportField_flags().field_qos().setValue(CC_Mqtt5QoS_AtLeastOnceDelivery);
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    

    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());
    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::MalformedPacket);
}

void UnitTestConnect::test28()
{
    // Testing bad reason code in AUTH message.
    // [MQTT-3.15.2-1]

    auto* client = unitTestAllocClient();

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &basicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnectAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);
    
    const UnitTestData BrokerAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::Success;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    

    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());
    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
}

void UnitTestConnect::test29()
{
    // Testing authentication rejection by broker
    // [MQTT-4.12.0-4]

    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnectAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    const UnitTestData AuthData = {0x11, 0x22, 0x33, 0x44};

    UnitTestAuthInfo authOutInfo;
    authOutInfo.m_authData = AuthData;
    unitTestAddOutAuth(authOutInfo);

    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    
    
    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(!unitTestIsConnectComplete());

    auto& inAuthInfo = unitTestInAuthInfo();
    TS_ASSERT_EQUALS(inAuthInfo.m_authData, BrokerAuthData);
    unitTestPopInAuthInfo();
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Auth);
    auto* authMsg = dynamic_cast<UnitTestAuthMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(authMsg, nullptr);
    TS_ASSERT(authMsg->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(authMsg->field_reasonCode().field().value(), UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth);

    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::NotAuthorized;
    auto& connackPropsVec = connackMsg.field_propertiesList().value();
    do {
        connackPropsVec.resize(connackPropsVec.size() + 1U);
        auto& propVar = connackPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(connectInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_NotAuthorized);
    unitTestPopConnectResponseInfo();    
}

void UnitTestConnect::test30()
{
    // Testing wrong AuthMethod in CONNACK
    // [MQTT-4.12.0-5]

    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnectAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    const UnitTestData AuthData = {0x11, 0x22, 0x33, 0x44};

    UnitTestAuthInfo authOutInfo;
    authOutInfo.m_authData = AuthData;
    unitTestAddOutAuth(authOutInfo);

    const std::string BrokerAuthMethod = "AuthMethod1";
    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = ConnectAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    
    
    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(!unitTestIsConnectComplete());

    auto& inAuthInfo = unitTestInAuthInfo();
    TS_ASSERT_EQUALS(inAuthInfo.m_authData, BrokerAuthData);
    unitTestPopInAuthInfo();
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Auth);
    auto* authMsg = dynamic_cast<UnitTestAuthMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(authMsg, nullptr);
    TS_ASSERT(authMsg->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(authMsg->field_reasonCode().field().value(), UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth);

    UnitTestConnackMsg connackMsg;
    connackMsg.field_reasonCode().value() = UnitTestConnackMsg::Field_reasonCode::ValueType::NotAuthorized;
    auto& connackPropsVec = connackMsg.field_propertiesList().value();
    do {
        connackPropsVec.resize(connackPropsVec.size() + 1U);
        auto& propVar = connackPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthMethod;
    } while (false);

    unitTestReceiveMessage(connackMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo(); 

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);   
}

void UnitTestConnect::test31()
{
    // Testing wrong AuthMethod in AUTH
    // [MQTT-4.12.0-5]

    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ConnectAuthMethod = "AuthMethod";
    const UnitTestData ConnectAuthData = {0x1, 0x2, 0x3, 0x5, 0xa};

    ec = unitTestConfigAuth(connect, ConnectAuthMethod, ConnectAuthData);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    const UnitTestData AuthData = {0x11, 0x22, 0x33, 0x44};

    // UnitTestAuthInfo authOutInfo;
    // authOutInfo.m_authData = AuthData;
    // unitTestAddOutAuth(authOutInfo);

    const std::string BrokerAuthMethod = "AuthMethod1";
    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    
    
    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo(); 

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);   
}

void UnitTestConnect::test32()
{
    // Testing unexpected AUTH message from broker
    // [MQTT-4.12.0-5]

    auto* client = unitTestAllocClient();
    TS_ASSERT_DIFFERS(client, nullptr);
    TS_ASSERT(unitTestCheckNoTicks());

    auto* connect = cc_mqtt5_client_connect_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(connect, nullptr);

    auto connectBasicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&connectBasicConfig);
    connectBasicConfig.m_cleanStart = true;
    auto ec = cc_mqtt5_client_connect_config_basic(connect, &connectBasicConfig);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendConnect(connect);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Connect);
    auto* connectMsg = dynamic_cast<UnitTestConnectMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(connectMsg, nullptr);

    const UnitTestData AuthData = {0x11, 0x22, 0x33, 0x44};

    const std::string BrokerAuthMethod = "AuthMethod1";
    const UnitTestData BrokerAuthData = {0x11, 0x22, 0x33, 0x44};

    unitTestTick(1000);
    UnitTestAuthMsg brokerAuthMsg;
    brokerAuthMsg.field_reasonCode().setExists();
    brokerAuthMsg.field_reasonCode().field().value() = UnitTestAuthMsg::Field_reasonCode::Field::ValueType::ContinueAuth;
    brokerAuthMsg.field_propertiesList().setExists();
    auto& authPropsVec = brokerAuthMsg.field_propertiesList().field().value();
    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authMethod();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthMethod;
    } while (false);

    do {
        authPropsVec.resize(authPropsVec.size() + 1U);
        auto& propVar = authPropsVec.back();
        auto& propBundle = propVar.initField_authData();
        auto& propValue = propBundle.field_value();
        propValue.value() = BrokerAuthData;
    } while (false);    
    
    unitTestReceiveMessage(brokerAuthMsg);
    TS_ASSERT(unitTestIsConnectComplete());

    auto& connectInfo = unitTestConnectResponseInfo();
    TS_ASSERT_EQUALS(connectInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopConnectResponseInfo(); 

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);   
}

