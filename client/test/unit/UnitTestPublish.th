#include "UnitTestCommonBase.h"
#include "UnitTestDefs.h"
#include "UnitTestPropsHandler.h"
#include "UnitTestProtocolDefs.h"

#include "client.h"

#include <cxxtest/TestSuite.h>

class UnitTestPublish : public CxxTest::TestSuite, public UnitTestCommonBase
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();
    void test26();
    void test27();
    void test28();
    void test29();
    void test30();
    void test31();
    void test32();
    void test33();
    void test34();

private:
    virtual void setUp() override
    {
        unitTestSetUp();
    }

    virtual void tearDown() override
    {
        unitTestTearDown();
    }
};

void UnitTestPublish::test1()
{
    // Qos0 publish with properties
    // [MQTT-3.3.1-2]
    // [MQTT-3.3.2-4]
    // [MQTT-3.3.2-5]
    // [MQTT-4.3.1-1]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    const bool Retain = true;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;
    TS_ASSERT_EQUALS(config.m_topicAliasPref, CC_Mqtt5TopicAliasPreference_UseAliasIfAvailable);
    config.m_retain = Retain;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const std::string ContentType("ContentType");
    const std::string ResponseTopic("ResponseTopic");
    const UnitTestData CorrelationData = {0x11, 0x22, 0x33, 0x44};
    const unsigned MsgExpiry = 10;
    const CC_Mqtt5PayloadFormat Format = CC_Mqtt5PayloadFormat_Utf8;

    auto extra = CC_Mqtt5PublishExtraConfig();
    ::cc_mqtt5_client_publish_init_config_extra(&extra);
    extra.m_contentType = ContentType.c_str();
    extra.m_responseTopic = ResponseTopic.c_str();
    extra.m_correlationData = &CorrelationData[0];
    extra.m_correlationDataLen = static_cast<decltype(extra.m_correlationDataLen)>(CorrelationData.size());
    extra.m_messageExpiryInterval = MsgExpiry;
    extra.m_format = Format;
    ec = ::cc_mqtt5_client_publish_config_extra(publish, &extra);

    const std::string PubUserPropKey1 = "Key1";
    const std::string PubUserPropVal1 = "Val1";    

    auto userProp1 = CC_Mqtt5UserProp();
    userProp1.m_key = PubUserPropKey1.c_str();
    userProp1.m_value = PubUserPropVal1.c_str();
    ec = ::cc_mqtt5_client_publish_add_user_prop(publish, &userProp1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->transportField_flags().field_retain().getBitValue_bit(), Retain);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().isMissing());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    UnitTestPropsHandler propsHandler;
    for (auto& p : publishMsg->field_propertiesList().value()) {
        p.currentFieldExec(propsHandler);
    }

    TS_ASSERT_DIFFERS(propsHandler.m_payloadFormatIndicator, nullptr);
    TS_ASSERT_EQUALS(static_cast<decltype(Format)>(propsHandler.m_payloadFormatIndicator->field_value().value()), Format);      
    TS_ASSERT_DIFFERS(propsHandler.m_messageExpiryInterval, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_messageExpiryInterval->field_value().value(), MsgExpiry);      
    TS_ASSERT_DIFFERS(propsHandler.m_responseTopic, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_responseTopic->field_value().value(), ResponseTopic);     
    TS_ASSERT_DIFFERS(propsHandler.m_correlationData, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_correlationData->field_value().value(), CorrelationData);       
    TS_ASSERT_DIFFERS(propsHandler.m_contentType, nullptr);
    TS_ASSERT_EQUALS(propsHandler.m_contentType->field_value().value(), ContentType);       
    TS_ASSERT_EQUALS(propsHandler.m_userProps.size(), 1U);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_first().value(), PubUserPropKey1);    
    TS_ASSERT_EQUALS(propsHandler.m_userProps[0]->field_value().field_second().value(), PubUserPropVal1);    
}

void UnitTestPublish::test2()
{
    // Simple Qos1 publish
    // [MQTT-4.3.1-1]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test3()
{
    // Simple Qos1 publish with response properties
    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    ::cc_mqtt5_client_connect_init_config_extra(&extraConfig);
    extraConfig.m_requestProblemInfo = true;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    
    const std::string UserPropKey2 = "Key2";
    const std::string UserPropVal2 = "Val2";    

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = NoSubscribers;
    pubackMsg.field_propertiesList().setExists();
    auto& propsVec = pubackMsg.field_propertiesList().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey2;
        field.field_value().field_second().value() = UserPropVal2;
    } while (false);    

    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(static_cast<decltype(NoSubscribers)>(pubackInfo.m_response.m_reasonCode), NoSubscribers);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_reasonStr, ReasonStr);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps.size(), 2U);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[0].m_key, UserPropKey1);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[0].m_value, UserPropVal1);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[1].m_key, UserPropKey2);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[1].m_value, UserPropVal2);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test4()
{
    // Timed out Qos1 publish
    // [MQTT-3.3.1-3]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(!publishMsg1->transportField_flags().field_dup().getBitValue_bit());

    // Timeout
    unitTestTick();
    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);    
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    // Another timeout
    unitTestTick();
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test5()
{
    // Simple Qos2 publish
    // [MQTT-4.3.3-2]
    // [MQTT-4.3.3-4]
    auto* client = unitTestAllocClient(true);
    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    ::cc_mqtt5_client_connect_init_config_extra(&extraConfig);
    extraConfig.m_requestProblemInfo = true;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT(!publishMsg->transportField_flags().field_dup().getBitValue_bit());
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubrecMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    
    const std::string UserPropKey2 = "Key2";
    const std::string UserPropVal2 = "Val2";        

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = NoSubscribers;
    pubrecMsg.field_propertiesList().setExists();
    auto& propsVec = pubrecMsg.field_propertiesList().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey2;
        field.field_value().field_second().value() = UserPropVal2;
    } while (false);    

    unitTestReceiveMessage(pubrecMsg);
    TS_ASSERT(!unitTestIsPublishComplete());

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    pubcompMsg.field_reasonCode().setExists();
    pubcompMsg.field_reasonCode().field().value() = NoSubscribers;
    pubcompMsg.field_propertiesList().setExists();
    auto& compPropsVec = pubcompMsg.field_propertiesList().field().value();
    do {
        compPropsVec.resize(compPropsVec.size() + 1U);
        auto& field = compPropsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    do {
        compPropsVec.resize(compPropsVec.size() + 1U);
        auto& field = compPropsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    do {
        compPropsVec.resize(compPropsVec.size() + 1U);
        auto& field = compPropsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey2;
        field.field_value().field_second().value() = UserPropVal2;
    } while (false);       
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_NoMatchingSubscribers);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_reasonStr, ReasonStr);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps.size(), 2U);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[0].m_key, UserPropKey1);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[0].m_value, UserPropVal1);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[1].m_key, UserPropKey2);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_userProps[1].m_value, UserPropVal2);

    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test6()
{
    // Timed out Qos2 publish
    // [MQTT-3.3.1-3]
    // [MQTT-4.3.3-5]
    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg1 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg1, nullptr);
    TS_ASSERT(!publishMsg1->transportField_flags().field_dup().getBitValue_bit());

    // Timeout
    unitTestTick();
    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);    
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg2->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);
    TS_ASSERT(!unitTestIsPublishComplete());

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT(!unitTestIsPublishComplete());

    // Timeout
    unitTestTick();
    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);   
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value()); 
    
    // Another timeout
    unitTestTick();
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();   
}

void UnitTestPublish::test7()
{
    // Qos0 publish with topic id
    // [MQTT-3.3.2-8]
    auto* client = unitTestAllocClient();
    unitTestPerformPubTopicAliasConnect(client, __FUNCTION__, 10);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    auto ec = ::cc_mqtt5_client_pub_topic_alias_alloc(client, Topic.c_str(), 2U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();
    } while (false);
    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);
        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }

        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);

    // Sending third time
    do {
        unitTestTick(1000);
        auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);
        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }

        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);    
}

void UnitTestPublish::test8()
{
    // Qos1 publish with topic id
    // [MQTT-3.3.2-8]
    auto* client = unitTestAllocClient();
    unitTestPerformPubTopicAliasConnect(client, __FUNCTION__, 10);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    auto ec = ::cc_mqtt5_client_pub_topic_alias_alloc(client, Topic.c_str(), 3U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();

        UnitTestPubackMsg pubackMsg;
        pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubackMsg);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();        
    } while (false);

    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());

        UnitTestPubackMsg pubackMsg;
        pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubackMsg);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();      
    } while (false);    
}

void UnitTestPublish::test9()
{
    // Qos2 publish with topic id
    // [MQTT-3.3.2-8]
    auto* client = unitTestAllocClient();
    unitTestPerformPubTopicAliasConnect(client, __FUNCTION__, 10);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    auto ec = ::cc_mqtt5_client_pub_topic_alias_alloc(client, Topic.c_str(), 3U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();

        unitTestTick(1000);
        UnitTestPubrecMsg pubrecMsg;
        pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubrecMsg);

        sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
        auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
        TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());        

        unitTestTick(1000);
        UnitTestPubcompMsg pubcompMsg;
        pubcompMsg.field_packetId().value() = pubrelMsg->field_packetId().value();
        unitTestReceiveMessage(pubcompMsg);

        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();        
    } while (false);

    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(!unitTestIsPublishComplete());

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());

        unitTestTick(1000);
        UnitTestPubrecMsg pubrecMsg;
        pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
        unitTestReceiveMessage(pubrecMsg);

        sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
        auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
        TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());        

        unitTestTick(1000);
        UnitTestPubcompMsg pubcompMsg;
        pubcompMsg.field_packetId().value() = pubrelMsg->field_packetId().value();
        unitTestReceiveMessage(pubcompMsg);

        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();     
    } while (false);    
}

void UnitTestPublish::test10()
{
    // Invalid publish topics
    // [MQTT-3.3.2-2]
    // [MQTT-4.7.2-1]
    // [MQTT-4.7.3-1]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = "hello/+/bla";
    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_topic = "hello/#";
    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    config.m_topic = "$hello";
    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    config.m_topic = "";
    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);     

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_InsufficientConfig);   
}

void UnitTestPublish::test11()
{
    // Testing invalid packet ID in PUBACK
    // [MQTT-2.2.1-5]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    // Unexpected packet ID in puback
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(publishMsg->field_packetId().field().value() + 1U);
    unitTestReceiveMessage(pubackMsg);
    
    TS_ASSERT(!unitTestIsPublishComplete());

    unitTestTick(); // timeout, send second time
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    // Unexpected packet ID in pubrec
    unitTestTick(1000);
    unitTestReceiveMessage(pubackMsg);

    unitTestTick(); // timeout
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test12()
{
    // Testing invalid packet ID in PUBREC
    // [MQTT-2.2.1-5]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    // Unexpected packet ID in pubrec
    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(publishMsg->field_packetId().field().value() + 1U);
    unitTestReceiveMessage(pubrecMsg);
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(); // timeout, send second time
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->transportField_flags().field_dup().getBitValue_bit());

    // Unexpected packet ID in pubrec
    unitTestTick(1000);
    unitTestReceiveMessage(pubrecMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg2 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg2, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg2->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(); // timeout
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}


void UnitTestPublish::test13()
{
    // Testing invalid packet ID in PUBCOMP
    // [MQTT-2.2.1-5]

    auto* client = unitTestAllocClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(publishMsg->field_packetId().field().value());
    unitTestReceiveMessage(pubrecMsg);
    
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    // Unexpected packet ID in PUBCOMP
    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().setValue(pubrecMsg.field_packetId().value() + 1U);
    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestHasSentMessage());

    unitTestTick(); // Retry timeout
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg2 = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg2, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg2->field_packetId().value(), pubrecMsg.field_packetId().value());

    // Same unexpected packet ID in PUBCOMP
    unitTestTick(1000);
    unitTestReceiveMessage(pubcompMsg);
    TS_ASSERT(!unitTestIsPublishComplete());
    TS_ASSERT(!unitTestHasSentMessage());

    unitTestTick(); // timeout
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Timeout);
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test14()
{
    // Suspending Qos1 publish operation when network is disconnected
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocClient();

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const unsigned ResponseTimeout = 2000;
    auto ec = cc_mqtt5_client_publish_set_response_timeout(publish, ResponseTimeout);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout);

    unitTestTick(1000);
    ::cc_mqtt5_client_notify_network_disconnected(client, true);

    TS_ASSERT(!unitTestIsPublishComplete());
    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(5000);
    ::cc_mqtt5_client_notify_network_disconnected(client, false);
    TS_ASSERT(!unitTestIsPublishComplete());

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout - 1000); // Resuming PUBACK timer

    ::cc_mqtt5_client_notify_network_disconnected(client, true);

    TS_ASSERT(!unitTestIsPublishComplete());
    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(); // Session expiry
    TS_ASSERT(unitTestIsPublishComplete());
    auto& responseInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(responseInfo.m_status, CC_Mqtt5AsyncOpStatus_BrokerDisconnected);
    unitTestPopPublishResponseInfo();
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestPublish::test15()
{
    // Suspending Qos2 publish operation when network is disconnected
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocClient();

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const UnitTestData Data = {0x11, 0x22, 0x33};
    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = "hello/bla";
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());    
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const unsigned ResponseTimeout = 2000;
    auto ec = cc_mqtt5_client_publish_set_response_timeout(publish, ResponseTimeout);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);   

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout);

    unitTestTick(1000);
    ::cc_mqtt5_client_notify_network_disconnected(client, true);

    TS_ASSERT(!unitTestIsPublishComplete());
    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(5000);
    ::cc_mqtt5_client_notify_network_disconnected(client, false);
    TS_ASSERT(!unitTestIsPublishComplete());

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout - 1000); // Resuming PUBREC timer

    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);
    TS_ASSERT(!unitTestIsPublishComplete());

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);
    TS_ASSERT_EQUALS(pubrelMsg->field_packetId().value(), pubrecMsg.field_packetId().value());

    unitTestTick(1000);
    ::cc_mqtt5_client_notify_network_disconnected(client, true);

    TS_ASSERT(!unitTestIsPublishComplete());
    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(); // Session expiry
    TS_ASSERT(unitTestIsPublishComplete());
    auto& responseInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(responseInfo.m_status, CC_Mqtt5AsyncOpStatus_BrokerDisconnected);
    unitTestPopPublishResponseInfo();
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestPublish::test16()
{
    // Testing rejection of "Reason String" in PUBACK
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = NoSubscribers;
    pubackMsg.field_propertiesList().setExists();
    auto& propsVec = pubackMsg.field_propertiesList().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test17()
{
    // Testing rejection of "User Properties" in PUBACK
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    

    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = NoSubscribers;
    pubackMsg.field_propertiesList().setExists();
    auto& propsVec = pubackMsg.field_propertiesList().field().value();

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());    
}

void UnitTestPublish::test18()
{
    // Testing rejection of "Reason String" in PUBREC
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = NoSubscribers;
    pubrecMsg.field_propertiesList().setExists();
    auto& propsVec = pubrecMsg.field_propertiesList().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test19()
{
    // Testing rejection of "User Properties" in PUBREL
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = NoSubscribers;
    pubrecMsg.field_propertiesList().setExists();
    auto& propsVec = pubrecMsg.field_propertiesList().field().value();

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());    
}

void UnitTestPublish::test20()
{
    // Testing rejection of "Reason String" in PUBCOMP
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string ReasonStr("ReasonStr");    

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    pubcompMsg.field_reasonCode().setExists();
    pubcompMsg.field_reasonCode().field().value() = NoSubscribers;
    pubcompMsg.field_propertiesList().setExists();
    auto& propsVec = pubcompMsg.field_propertiesList().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_reasonStr();
        field.field_value().value() = ReasonStr;
    } while (false);

    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test21()
{
    // Testing rejection of "User Properties" in PUBCOMP
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};
    const CC_Mqtt5QoS Qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = Qos;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
    TS_ASSERT(!unitTestIsPublishComplete());

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT_EQUALS(static_cast<decltype(Qos)>(publishMsg->transportField_flags().field_qos().value()), Qos);
    TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_payload().value(), Data);

    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().value() = publishMsg->field_packetId().field().value();
    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(!unitTestIsPublishComplete());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrel);    
    auto* pubrelMsg = dynamic_cast<UnitTestPubrelMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrelMsg, nullptr);

    const auto NoSubscribers = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NoMatchingSubscribers;
    const std::string UserPropKey1 = "Key1";
    const std::string UserPropVal1 = "Val1";    

    unitTestTick(1000);
    UnitTestPubcompMsg pubcompMsg;
    pubcompMsg.field_packetId().value() = pubrecMsg.field_packetId().value();
    pubcompMsg.field_reasonCode().setExists();
    pubcompMsg.field_reasonCode().field().value() = NoSubscribers;
    pubcompMsg.field_propertiesList().setExists();
    auto& propsVec = pubcompMsg.field_propertiesList().field().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().value() = UserPropKey1;
        field.field_value().field_second().value() = UserPropVal1;
    } while (false);

    unitTestReceiveMessage(pubcompMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestPublish::test22()
{
    // Testing rejection of publish with QoS higher than allowed by broker
    // [MQTT-3.2.2-11]
    // [MQTT-4.9.0-2]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_maxQos = CC_Mqtt5QoS_AtMostOnceDelivery;
    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);

    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;
    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestIsPublishComplete());
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test23()
{
    // Testing rejection of publish with retain when it's unavailable
    // [MQTT-3.2.2-14]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    bool retainAvailable = false;
    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_retainAvailable = &retainAvailable;
    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);

    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    config.m_retain = true;

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);

    config.m_retain = false;
    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    TS_ASSERT(unitTestIsPublishComplete());
    unitTestPopPublishResponseInfo();
}

void UnitTestPublish::test24()
{
    // Testing rejection of publish exceeding max packet size
    // [MQTT-3.2.2-15]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    const unsigned MaxPacketSize = 300;
    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_maxPacketSize = MaxPacketSize;
    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);

    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data(MaxPacketSize, 0x1);

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);
    TS_ASSERT_EQUALS(publish, nullptr);

    publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size() - 100U);
    ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    

    TS_ASSERT(unitTestIsPublishComplete());
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test25()
{
    // Testing rejection of invalid QoS value
    // [MQTT-3.3.1-4]
    
    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);

    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = static_cast<decltype(config.m_qos)>(3);

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    
}

void UnitTestPublish::test26()
{
    // Qos0 publish with topic alias with network disconnection
    // [MQTT-3.3.2-7]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    ::cc_mqtt5_client_connect_init_config_extra(&extraConfig);
    extraConfig.m_sessionExpiryInterval = 10;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_topicAliasMax = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig, nullptr, &responseConfig);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    auto ec = ::cc_mqtt5_client_pub_topic_alias_alloc(client, Topic.c_str(), 1U);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);
    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;

    unsigned alias = 0U;
    do {
        auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        alias = propsHandler.m_topicAlias->field_value().value();
    } while (false);
    TS_ASSERT_DIFFERS(alias, 0U);

    // Sending second time
    do {
        unitTestTick(1000);
        auto publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);
        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT(publishMsg->field_topic().value().empty());

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }

        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);   
    
    unitTestTick(1000);
    ::cc_mqtt5_client_notify_network_disconnected(client, true);
    ::cc_mqtt5_client_notify_network_disconnected(client, false);
     
    do {
        auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
        TS_ASSERT_DIFFERS(publish, nullptr);

        ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        
        ec = unitTestSendPublish(publish);
        TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);
        TS_ASSERT(unitTestIsPublishComplete());
        unitTestPopPublishResponseInfo();

        auto sentMsg = unitTestGetSentMessage();
        TS_ASSERT(sentMsg);
        TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
        auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(publishMsg, nullptr);
        TS_ASSERT_EQUALS(publishMsg->field_topic().value(), Topic);

        UnitTestPropsHandler propsHandler;
        for (auto& p : publishMsg->field_propertiesList().value()) {
            p.currentFieldExec(propsHandler);
        }
        
        TS_ASSERT_DIFFERS(propsHandler.m_topicAlias, nullptr);
        TS_ASSERT_EQUALS(alias, propsHandler.m_topicAlias->field_value().value());
    } while (false);     
}

void UnitTestPublish::test27()
{
    // Testing inability to use wildcards in "Response Topic"
    // [MQTT-3.3.2-14]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    auto extra = CC_Mqtt5PublishExtraConfig();
    ::cc_mqtt5_client_publish_init_config_extra(&extra);
    extra.m_responseTopic = "#";

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_extra(publish, &extra);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    extra.m_responseTopic = "hello/+";
    ec = ::cc_mqtt5_client_publish_config_extra(publish, &extra);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_BadParam);    

    extra.m_responseTopic = "bla";
    ec = ::cc_mqtt5_client_publish_config_extra(publish, &extra);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);    
}

void UnitTestPublish::test28()
{
    // Testing incoming PUBREC instead of PUBACK
    // [MQTT-3.3.4-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId);
   
    unitTestReceiveMessage(pubrecMsg);   
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestPublish::test29()
{
    // Testing incoming PUBACK instead of PUBREC
    // [MQTT-3.3.4-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId);
   
    unitTestReceiveMessage(pubackMsg);   
    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubInfo.m_status, CC_Mqtt5AsyncOpStatus_ProtocolError);
    unitTestPopPublishResponseInfo();

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestPublish::test30()
{
    // Testing limit of the outgoing high Qos publishes
    // [MQTT-3.3.4-7]

    auto* client = unitTestAllocClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    ::cc_mqtt5_client_connect_init_config_basic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    UnitTestConnectResponseConfig responseConfig;
    responseConfig.m_recvMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, nullptr, nullptr, &responseConfig);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));    

    const std::string Topic("some/topic");
    const UnitTestData Data = { 0x1, 0x2, 0x3, 0x4, 0x5};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);

    TS_ASSERT(!unitTestIsPublishComplete());

    auto* publish2 = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    config.m_qos = CC_Mqtt5QoS_AtMostOnceDelivery;
    ec = ::cc_mqtt5_client_publish_config_basic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success); 
    
    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);    

    TS_ASSERT(unitTestIsPublishComplete());
    unitTestPopPublishResponseInfo();    

    auto* publish3 = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish3, nullptr);

    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;
    ec = ::cc_mqtt5_client_publish_config_basic(publish3, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Busy); 
}

void UnitTestPublish::test31()
{
    // Testing rejection of the Qos1 publish by the broker
    // [MQTT-4.4.0-2]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubackMsg pubackMsg;
    pubackMsg.field_packetId().setValue(packetId);
    pubackMsg.field_reasonCode().setExists();
    pubackMsg.field_reasonCode().field().value() = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::UnspecifiedError;
    unitTestReceiveMessage(pubackMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_UnspecifiedError);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test32()
{
    // Testing rejection of the Qos2 publish by the broker
    // [MQTT-4.4.0-2]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic("some/topic");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId = publishMsg->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId, 0U);
    
    unitTestTick(1000);
    UnitTestPubrecMsg pubrecMsg;
    pubrecMsg.field_packetId().setValue(packetId);
    pubrecMsg.field_reasonCode().setExists();
    pubrecMsg.field_reasonCode().field().value() = UnitTestPubackMsg::Field_reasonCode::Field::ValueType::UnspecifiedError;
    unitTestReceiveMessage(pubrecMsg);

    TS_ASSERT(unitTestIsPublishComplete());
    auto& pubackInfo = unitTestPublishResponseInfo();
    TS_ASSERT_EQUALS(pubackInfo.m_status, CC_Mqtt5AsyncOpStatus_Complete);
    TS_ASSERT_EQUALS(pubackInfo.m_response.m_reasonCode, CC_Mqtt5ReasonCode_UnspecifiedError);
    unitTestPopPublishResponseInfo();    
}

void UnitTestPublish::test33()
{
    // Testing re-publish of not acked Qos1 messages in the same order.
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic1("some/topic1");
    const std::string Topic2("some/topic2");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish1 = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    // Not delay between publishes.
    config.m_topic = Topic2.c_str();

    auto* publish2 = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    ec = ::cc_mqtt5_client_publish_config_basic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    auto packetId2 = publishMsg2->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId1, packetId2);

    unitTestTick(); // Timeout
    TS_ASSERT(!unitTestIsPublishComplete());

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);


    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg2->field_packetId().field().value(), packetId2);

    TS_ASSERT(!unitTestIsPublishComplete());
}

void UnitTestPublish::test34()
{
    // Testing re-publish of not acked Qos1 and Qos2 messages in the same order.
    // [MQTT-4.6.0-1]

    auto* client = unitTestAllocClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(::cc_mqtt5_client_is_connected(client));

    const std::string Topic1("some/topic1");
    const std::string Topic2("some/topic2");
    const UnitTestData Data = {0x1, 0x2, 0x3};

    auto config = CC_Mqtt5PublishBasicConfig();
    ::cc_mqtt5_client_publish_init_config_basic(&config);

    config.m_topic = Topic1.c_str();
    config.m_data = &Data[0];
    config.m_dataLen = static_cast<decltype(config.m_dataLen)>(Data.size());
    config.m_qos = CC_Mqtt5QoS_ExactlyOnceDelivery;

    auto* publish1 = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish1, nullptr);

    auto ec = ::cc_mqtt5_client_publish_config_basic(publish1, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish1);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    auto packetId1 = publishMsg->field_packetId().field().value();

    // Not delay between publishes.
    config.m_topic = Topic2.c_str();
    config.m_qos = CC_Mqtt5QoS_AtLeastOnceDelivery;

    auto* publish2 = ::cc_mqtt5_client_publish_prepare(client, nullptr);
    TS_ASSERT_DIFFERS(publish2, nullptr);

    ec = ::cc_mqtt5_client_publish_config_basic(publish2, &config);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);

    ec = unitTestSendPublish(publish2);
    TS_ASSERT_EQUALS(ec, CC_Mqtt5ErrorCode_Success);  

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    auto* publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    auto packetId2 = publishMsg2->field_packetId().field().value();
    TS_ASSERT_DIFFERS(packetId1, packetId2);

    unitTestTick(); // Timeout
    TS_ASSERT(!unitTestIsPublishComplete());

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg, nullptr);
    TS_ASSERT(publishMsg->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg->field_packetId().field().value(), packetId1);


    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Publish);    
    publishMsg2 = dynamic_cast<UnitTestPublishMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(publishMsg2, nullptr);
    TS_ASSERT(publishMsg2->field_packetId().doesExist());
    TS_ASSERT_EQUALS(publishMsg2->field_packetId().field().value(), packetId2);

    TS_ASSERT(!unitTestIsPublishComplete());
}