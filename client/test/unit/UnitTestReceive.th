#include "UnitTestDefaultBase.h"
#include "UnitTestPropsHandler.h"
#include "UnitTestProtocolDefs.h"

#include "client.h"

#include <cxxtest/TestSuite.h>

class UnitTestReceive : public CxxTest::TestSuite, public UnitTestDefaultBase
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();

private:
    virtual void setUp() override
    {
        unitTestSetUp();
    }

    virtual void tearDown() override
    {
        unitTestTearDown();
    }
};

void UnitTestReceive::test1()
{
    // Simple receive of Qos0
    // [MQTT-3.3.2-4]
    // [MQTT-3.3.2-6]
    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned MessageExpiryInterval = 10;
    const std::string ResponseTopic = "ResponseTopic";
    const UnitTestData CorrelationData = {0x21, 0x32, 0x43, 0x54};
    const CC_Mqtt5PayloadFormat Format = CC_Mqtt5PayloadFormat_Utf8;
    const bool Retain = true;
    const std::string ContentType("ContentType");
    const std::string UserPropKey1("Key1");
    const std::string UserPropVal1("Val1");

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_retain().setBitValue_bit(Retain);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    auto& propsVec = publishMsg.field_properties().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_payloadFormatIndicator();
        field.field_value().setValue(Format);
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_messageExpiryInterval();
        field.field_value().setValue(MessageExpiryInterval);
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_responseTopic();
        field.field_value().setValue(ResponseTopic);
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_correlationData();
        field.field_value().setValue(CorrelationData);
    } while (false);       

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_contentType();
        field.field_value().setValue(ContentType);
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().setValue(UserPropKey1);
        field.field_value().field_second().setValue(UserPropVal1);
    } while (false);    

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo.m_responseTopic, ResponseTopic);
    TS_ASSERT_EQUALS(msgInfo.m_correlationData, CorrelationData);
    TS_ASSERT_EQUALS(msgInfo.m_userProps.size(), 1U);
    TS_ASSERT_EQUALS(msgInfo.m_userProps[0].m_key, UserPropKey1);
    TS_ASSERT_EQUALS(msgInfo.m_userProps[0].m_value, UserPropVal1);
    TS_ASSERT_EQUALS(msgInfo.m_contentType, ContentType);
    TS_ASSERT_EQUALS(msgInfo.m_messageExpiryInterval, MessageExpiryInterval);
    TS_ASSERT(msgInfo.m_subIds.empty());
    TS_ASSERT_EQUALS(msgInfo.m_qos, CC_Mqtt5QoS_AtMostOnceDelivery);
    TS_ASSERT_EQUALS(msgInfo.m_format, Format);
    TS_ASSERT_EQUALS(msgInfo.m_retained, Retain);
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test2()
{
    // Simple receive of Qos1
    // [MQTT-4.3.2-4]
    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::AtLeastOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Puback);    
    auto* pubackMsg = dynamic_cast<UnitTestPubackMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubackMsg, nullptr);
    TS_ASSERT_EQUALS(pubackMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubackMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubackMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo.m_qos, CC_Mqtt5QoS_AtLeastOnceDelivery);
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test3()
{
    // Simple receive of Qos2
    // [MQTT-3.3.2-4]
    // [MQTT-3.3.2-6]
    // [MQTT-4.3.3-8]
    // [MQTT-4.3.3-11]
    auto* client = unitTestAllocAndInitClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_requestProblemInfo = true;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    const unsigned SubId = 10;

    unitTestPerformBasicSubscribe(client, "#", SubId);
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned MessageExpiryInterval = 10;
    const std::string ResponseTopic = "ResponseTopic";
    const UnitTestData CorrelationData = {0x21, 0x32, 0x43, 0x54};
    const CC_Mqtt5PayloadFormat Format = CC_Mqtt5PayloadFormat_Utf8;
    const bool Retain = true;
    const std::string ContentType("ContentType");
    const std::string UserPropKey1("Key1");
    const std::string UserPropVal1("Val1");
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_retain().setBitValue_bit(Retain);
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    auto& propsVec = publishMsg.field_properties().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_payloadFormatIndicator();
        field.field_value().setValue(Format);
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_messageExpiryInterval();
        field.field_value().setValue(MessageExpiryInterval);
    } while (false);

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_responseTopic();
        field.field_value().setValue(ResponseTopic);
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_correlationData();
        field.field_value().setValue(CorrelationData);
    } while (false);       

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_contentType();
        field.field_value().setValue(ContentType);
    } while (false);     

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().setValue(UserPropKey1);
        field.field_value().field_second().setValue(UserPropVal1);
    } while (false);    

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_subscriptionId();
        field.field_value().setValue(SubId);
    } while (false);               

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    const std::string PubrelReasonStr("ReasonStr");
    const std::string PubrelUserPropKey("PubrelKey1");
    const std::string PubrelUserPropVal("PubrelVal1");

    unitTestTick(1000);
    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    pubrelMsg.field_reasonCode().setExists();
    pubrelMsg.field_properties().setExists();
    auto& pubrelPropsVec = pubrelMsg.field_properties().field().value();
    do {
        pubrelPropsVec.resize(pubrelPropsVec.size() + 1U);
        auto& field = pubrelPropsVec.back().initField_reasonStr();
        field.field_value().setValue(PubrelReasonStr);
    } while (false);

    do {
        pubrelPropsVec.resize(pubrelPropsVec.size() + 1U);
        auto& field = pubrelPropsVec.back().initField_userProperty();
        field.field_value().field_first().setValue(PubrelUserPropKey);
        field.field_value().field_second().setValue(PubrelUserPropVal);
    } while (false);    

    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubcompMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo.m_responseTopic, ResponseTopic);
    TS_ASSERT_EQUALS(msgInfo.m_correlationData, CorrelationData);
    TS_ASSERT_EQUALS(msgInfo.m_userProps.size(), 2U);
    TS_ASSERT_EQUALS(msgInfo.m_userProps[0].m_key, UserPropKey1);
    TS_ASSERT_EQUALS(msgInfo.m_userProps[0].m_value, UserPropVal1);
    TS_ASSERT_EQUALS(msgInfo.m_userProps[1].m_key, PubrelUserPropKey);
    TS_ASSERT_EQUALS(msgInfo.m_userProps[1].m_value, PubrelUserPropVal);    
    TS_ASSERT_EQUALS(msgInfo.m_contentType, ContentType);
    TS_ASSERT_EQUALS(msgInfo.m_subIds.size(), 1U);
    TS_ASSERT_EQUALS(msgInfo.m_subIds[0], SubId);
    TS_ASSERT_EQUALS(msgInfo.m_messageExpiryInterval, MessageExpiryInterval);
    TS_ASSERT_EQUALS(msgInfo.m_qos, CC_Mqtt5QoS_ExactlyOnceDelivery);
    TS_ASSERT_EQUALS(msgInfo.m_format, Format);
    TS_ASSERT_EQUALS(msgInfo.m_retained, Retain);
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test4()
{
    // Testing rejection of the allocated packet Id in Qos2 publish.
    // [MQTT-2.2.1-4]

    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const unsigned SubId = 10;

    unitTestPerformBasicSubscribe(client, "#", SubId);
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    unitTestTick(1000);

    // Second send of the same publish without dup flag

    unitTestReceiveMessage(publishMsg);
    sentMsg = unitTestGetSentMessage();
    auto* pubrecMsg2 = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg2, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg2->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg2->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(pubrecMsg2->field_reasonCode().field().value(), UnitTestPubrecMsg::Field_reasonCode::Field::ValueType::PacketIdInUse);


    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubcompMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo.m_qos, CC_Mqtt5QoS_ExactlyOnceDelivery);
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test5()
{
    // Testing invalid packet ID in PUBREL
    // [MQTT-2.2.1-5]

    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    unitTestTick(1000);

    // Sending PUBREL with invalid packet id;
    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(publishMsg.field_packetId().field().value() + 1U);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), pubrelMsg.field_packetId().value());
    TS_ASSERT(pubcompMsg->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(pubcompMsg->field_reasonCode().field().value(), UnitTestPubrecMsg::Field_reasonCode::Field::ValueType::PacketIdNotFound);

    unitTestTick();
}

void UnitTestReceive::test6()
{
    // Testing network disconnection during reception of Qos2 message
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocAndInitClient();

    const unsigned ResponseTimeout = 2000;
    unitTestSetDefaultResponseTimeout(client, ResponseTimeout);

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout);

    unitTestTick(1000);
    unitTestNotifyClientDisconnected(client, true);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(5000);
    unitTestNotifyClientDisconnected(client, false);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout - 1000); 

    // Sending PUBREL with invalid packet id;
    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);

    TS_ASSERT(unitTestHasMessageRecieved());
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test7()
{
    // Testing network disconnection during reception of Qos2 message
    // [MQTT-3.1.2-23]

    auto* client = unitTestAllocAndInitClient();

    const unsigned ResponseTimeout = 2000;
    unitTestSetDefaultResponseTimeout(client, ResponseTimeout);

    const unsigned SessionExpiryInterval = 10;
    unitTestPerformSessionExpiryConnect(client, __FUNCTION__, SessionExpiryInterval);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);

    auto* tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, ResponseTimeout);

    unitTestTick(1000);
    unitTestNotifyClientDisconnected(client, true);

    tickReq = unitTestTickReq();
    TS_ASSERT_EQUALS(tickReq->m_requested, SessionExpiryInterval * 1000); // Expecting to measure session expiry interval

    unitTestTick(); // Session expiry
    TS_ASSERT(!unitTestHasMessageRecieved());
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestReceive::test8()
{
    // Rejecting packet bigger than configured.
    // [MQTT-3.1.2-24]

    auto* client = unitTestAllocAndInitClient();
    TS_ASSERT(!unitTestIsConnected(client));

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_maxPacketSize = 300;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const std::size_t PayloadLimit = 
        sizeof(std::uint8_t) + // frame's ID + FLAGS
        sizeof(std::uint16_t) + // frame's size
        Topic.size() + sizeof(std::uint16_t) + // Topic string
        sizeof(std::uint8_t); // properties length

    const UnitTestData Data((extraConfig.m_maxPacketSize - PayloadLimit) + 1U, 0x11);

    UnitTestPublishMsg publishMsg;
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    TS_ASSERT(unitTestIsDisconnected());    

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::PacketTooLarge);
}

void UnitTestReceive::test9()
{
    // Testing rejection of "Reason String" in PUBREL
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocAndInitClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;
    const std::string UserPropKey1("Key1");
    const std::string UserPropVal1("Val1");    

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    auto& propsVec = publishMsg.field_properties().value();

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().setValue(UserPropKey1);
        field.field_value().field_second().setValue(UserPropVal1);
    } while (false);

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);

    const std::string PubrelUserPropKey("PubrelKey1");
    const std::string PubrelUserPropVal("PubrelVal1");

    unitTestTick(1000);
    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    pubrelMsg.field_reasonCode().setExists();
    pubrelMsg.field_properties().setExists();
    auto& pubrelPropsVec = pubrelMsg.field_properties().field().value();
    do {
        pubrelPropsVec.resize(pubrelPropsVec.size() + 1U);
        auto& field = pubrelPropsVec.back().initField_userProperty();
        field.field_value().field_first().setValue(PubrelUserPropKey);
        field.field_value().field_second().setValue(PubrelUserPropVal);
    } while (false);    

    unitTestReceiveMessage(pubrelMsg);

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestReceive::test10()
{
    // Testing rejection of "User Properties" in PUBREL
    // [MQTT-3.1.2-29]

    auto* client = unitTestAllocAndInitClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;
    const std::string UserPropKey1("Key1");
    const std::string UserPropVal1("Val1");    

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    auto& propsVec = publishMsg.field_properties().value();

    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_userProperty();
        field.field_value().field_first().setValue(UserPropKey1);
        field.field_value().field_second().setValue(UserPropVal1);
    } while (false);

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);

    const std::string PubrelReasonStr("ReasonStr");

    unitTestTick(1000);
    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    pubrelMsg.field_reasonCode().setExists();
    pubrelMsg.field_properties().setExists();
    auto& pubrelPropsVec = pubrelMsg.field_properties().field().value();
    do {
        pubrelPropsVec.resize(pubrelPropsVec.size() + 1U);
        auto& field = pubrelPropsVec.back().initField_reasonStr();
        field.field_value().setValue(PubrelReasonStr);
    } while (false);
    unitTestReceiveMessage(pubrelMsg);

    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ProtocolError);
    TS_ASSERT(unitTestIsDisconnected());      
}

void UnitTestReceive::test11()
{
    // Testing reception of the DUP bit set when PUBREC is not received by the broker
    // [MQTT-3.3.1-1]
    // [MQTT-4.3.3-10]

    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const unsigned SubId = 10;

    unitTestPerformBasicSubscribe(client, "#", SubId);
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    unitTestTick(1000);

    // Second send of the same publish with dup flag
    publishMsg.transportField_flags().field_dup().setBitValue_bit(true);

    unitTestReceiveMessage(publishMsg);

    sentMsg = unitTestGetSentMessage();
    auto* pubrecMsg2 = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg2, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg2->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg2->field_reasonCode().isMissing());

    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubcompMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo.m_qos, CC_Mqtt5QoS_ExactlyOnceDelivery);
    unitTestPopReceivedMessageInfo();
}


void UnitTestReceive::test12()
{
    // Testing reception of the DUP bit set right away (first PUBLISH was missed)
    // [MQTT-3.3.1-1]

    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.transportField_flags().field_dup().setBitValue_bit(true);
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    unitTestTick(1000);

    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubcompMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo.m_qos, CC_Mqtt5QoS_ExactlyOnceDelivery);
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test13()
{
    // Testing reception of the unsolicited message
    // [MQTT-3.3.2-3]

    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "topic1/#");
    unitTestTick(1000);

    const std::string Topic = "topic2";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::AtMostOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    
    TS_ASSERT(!unitTestHasMessageRecieved()); // ignored
    TS_ASSERT(!unitTestHasSentMessage());

    unitTestTick(1000);
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::AtLeastOnceDelivery;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    
    TS_ASSERT(!unitTestHasMessageRecieved()); // ignored

    TS_ASSERT(unitTestHasSentMessage());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Puback);    
    auto* pubackMsg = dynamic_cast<UnitTestPubackMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubackMsg, nullptr);
    TS_ASSERT_EQUALS(pubackMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubackMsg->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(pubackMsg->field_reasonCode().field().value(), UnitTestPubackMsg::Field_reasonCode::Field::ValueType::NotAuthorized);

    unitTestTick(1000);
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(pubrecMsg->field_reasonCode().field().value(), UnitTestPubrecMsg::Field_reasonCode::Field::ValueType::NotAuthorized);
    TS_ASSERT(!unitTestHasMessageRecieved()); // ignored
}

void UnitTestReceive::test14()
{
    // Testing reception of topic aliases
    // [MQTT-3.3.2-10]

    auto* client = unitTestAllocAndInitClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_topicAliasMaximum = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;
    const unsigned TopicAlias = 5;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::AtMostOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    auto& propsVec = publishMsg.field_properties().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_topicAlias();
        field.field_value().setValue(TopicAlias);
    } while (false);
    
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo2 = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo2.m_topic, Topic);
    unitTestPopReceivedMessageInfo();

    unitTestTick(1000);
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::AtLeastOnceDelivery;
    publishMsg.field_topic().value().clear();
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    

    TS_ASSERT(unitTestHasSentMessage());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Puback);    
    auto* pubackMsg = dynamic_cast<UnitTestPubackMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubackMsg, nullptr);
    TS_ASSERT(pubackMsg->field_reasonCode().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo1 = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo1.m_topic, Topic);
    unitTestPopReceivedMessageInfo();

    unitTestTick(1000);
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());

    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);   

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo3 = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo3.m_topic, Topic);
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test15()
{
    // Testing reception of invalid topic alias
    // [MQTT-3.3.2-10]

    auto* client = unitTestAllocAndInitClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_topicAliasMaximum = 10;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;
    const unsigned TopicAlias = 15;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::AtMostOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    auto& propsVec = publishMsg.field_properties().value();
    do {
        propsVec.resize(propsVec.size() + 1U);
        auto& field = propsVec.back().initField_topicAlias();
        field.field_value().setValue(TopicAlias);
    } while (false);
    
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    

    TS_ASSERT(!unitTestHasMessageRecieved());
    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::TopicAliasInvalid);
    TS_ASSERT(unitTestIsDisconnected());
}

void UnitTestReceive::test16()
{
    // Testing exceeding "Receive Maximum" value by the broker
    // [MQTT-3.3.4-9]

    auto* client = unitTestAllocAndInitClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_receiveMaximum = 1;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());    

    // Send again with different PacketId
    publishMsg.field_packetId().field().setValue(PacketId + 1U);
    unitTestReceiveMessage(publishMsg);  

    TS_ASSERT(!unitTestHasMessageRecieved());
    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::ReceiveMaxExceeded);
    TS_ASSERT(unitTestIsDisconnected());             
}

void UnitTestReceive::test17()
{
    // Testing invalid PUBREL
    // [MQTT-3.6.1-1]

    auto* client = unitTestAllocAndInitClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());  

    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);    

    TS_ASSERT(!unitTestHasMessageRecieved());
    unitTestVerifyDisconnectSent(UnitTestDisconnectReason::MalformedPacket);
    TS_ASSERT(unitTestIsDisconnected());             
}

void UnitTestReceive::test18()
{
    // Finish reception of the Qos2 message after unsubscribe
    // [MQTT-3.10.4-3]

    auto* client = unitTestAllocAndInitClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    const unsigned SubId = 10;

    unitTestPerformBasicSubscribe(client, "#", SubId);
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    unitTestPerformBasicSubscribe(client, "#", SubId);

    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubcompMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    unitTestPopReceivedMessageInfo();
}

void UnitTestReceive::test19()
{
    // Testing double receive of the same Qos1 message
    // [MQTT-4.3.2-5]

    auto* client = unitTestAllocAndInitClient();

    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::AtLeastOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;

    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);  

    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Puback);    
    auto* pubackMsg = dynamic_cast<UnitTestPubackMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubackMsg, nullptr);
    TS_ASSERT_EQUALS(pubackMsg->field_packetId().value(), PacketId);

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo.m_qos, CC_Mqtt5QoS_AtLeastOnceDelivery);
    unitTestPopReceivedMessageInfo();  

    // Assume PUBACK is not received by the broker
    publishMsg.transportField_flags().field_dup().setBitValue_bit(true);
    unitTestReceiveMessage(publishMsg);  

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Puback);    
    pubackMsg = dynamic_cast<UnitTestPubackMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubackMsg, nullptr);
    TS_ASSERT_EQUALS(pubackMsg->field_packetId().value(), PacketId);

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo2 = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo2.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo2.m_data, Data);
    TS_ASSERT_EQUALS(msgInfo2.m_qos, CC_Mqtt5QoS_AtLeastOnceDelivery);
    unitTestPopReceivedMessageInfo();    
}

void UnitTestReceive::test20()
{
    // Testing PUBLISH after rejecting PUBREC
    // [MQTT-4.3.3-9]

    auto* client = unitTestAllocAndInitClient();
    unitTestPerformBasicConnect(client, __FUNCTION__);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "topic1/#");
    unitTestTick(1000);

    const std::string Topic = "topic2";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);    
    TS_ASSERT(!unitTestHasMessageRecieved());

    TS_ASSERT(unitTestHasSentMessage());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().doesExist());
    TS_ASSERT_EQUALS(pubrecMsg->field_reasonCode().field().value(), UnitTestPubrecMsg::Field_reasonCode::Field::ValueType::NotAuthorized);
    TS_ASSERT(!unitTestHasMessageRecieved());

    publishMsg.field_topic().value() = "topic1";
    unitTestReceiveMessage(publishMsg);    
    TS_ASSERT(!unitTestHasMessageRecieved()); 

    TS_ASSERT(unitTestHasSentMessage());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
}

void UnitTestReceive::test21()
{
    // Double reception of the same Qos2 message after ack
    // [MQTT-4.3.3-12]

    auto* client = unitTestAllocAndInitClient();

    auto basicConfig = CC_Mqtt5ConnectBasicConfig();
    unitTestConnectInitConfigBasic(&basicConfig);
    basicConfig.m_clientId = __FUNCTION__;
    basicConfig.m_cleanStart = true;

    auto extraConfig = CC_Mqtt5ConnectExtraConfig();
    unitTestConnectInitConfigExtra(&extraConfig);
    extraConfig.m_requestProblemInfo = true;

    unitTestPerformConnect(client, &basicConfig, nullptr, &extraConfig);
    TS_ASSERT(unitTestIsConnected(client));

    unitTestPerformBasicSubscribe(client, "#");
    unitTestTick(1000);

    const std::string Topic = "some/topic";
    const UnitTestData Data = {'h', 'e', 'l', 'l', 'o'};
    const unsigned PacketId = 10;

    UnitTestPublishMsg publishMsg;
    publishMsg.transportField_flags().field_qos().value() = UnitTestPublishMsg::TransportField_flags::Field_qos::ValueType::ExactlyOnceDelivery;
    publishMsg.field_packetId().field().setValue(PacketId);
    publishMsg.field_topic().value() = Topic;
    publishMsg.field_payload().value() = Data;
    publishMsg.doRefresh();
    unitTestReceiveMessage(publishMsg);

    TS_ASSERT(!unitTestHasMessageRecieved());
    auto sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    auto* pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    unitTestTick(1000);
    UnitTestPubrelMsg pubrelMsg;
    pubrelMsg.field_packetId().setValue(PacketId);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    auto* pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubcompMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo.m_data, Data);
    unitTestPopReceivedMessageInfo();

    // Receive it again
    unitTestReceiveMessage(publishMsg);
    TS_ASSERT(!unitTestHasMessageRecieved());
    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubrec);    
    pubrecMsg = dynamic_cast<UnitTestPubrecMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubrecMsg, nullptr);
    TS_ASSERT_EQUALS(pubrecMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubrecMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubrecMsg->field_properties().isMissing());

    unitTestTick(1000);
    unitTestReceiveMessage(pubrelMsg);

    sentMsg = unitTestGetSentMessage();
    TS_ASSERT(sentMsg);
    TS_ASSERT_EQUALS(sentMsg->getId(), cc_mqtt5::MsgId_Pubcomp);    
    pubcompMsg = dynamic_cast<UnitTestPubcompMsg*>(sentMsg.get());
    TS_ASSERT_DIFFERS(pubcompMsg, nullptr);
    TS_ASSERT_EQUALS(pubcompMsg->field_packetId().value(), PacketId);
    TS_ASSERT(pubcompMsg->field_reasonCode().isMissing());
    TS_ASSERT(pubcompMsg->field_properties().isMissing());

    TS_ASSERT(unitTestHasMessageRecieved());
    auto& msgInfo2 = unitTestReceivedMessageInfo();
    TS_ASSERT_EQUALS(msgInfo2.m_topic, Topic);
    TS_ASSERT_EQUALS(msgInfo2.m_data, Data);
    unitTestPopReceivedMessageInfo();    
}
